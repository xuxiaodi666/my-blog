<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/22/%E7%AE%97%E6%B3%95/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/22/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给一个字符串，要求返回做多的字符和个数<br>  输入 “abcba”<br>  输出 {a:2,b:2}<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findMostFrequentCharacters</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">const</span> charCount = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> maxCount = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 统计字符出现的次数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> char = str[i];<br>    charCount[char] = (charCount[char] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>    maxCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxCount, charCount[char]);<br>  &#125;<br><br>  <span class="hljs-comment">// 找出出现次数最多的字符</span><br>  <span class="hljs-keyword">const</span> mostFrequentChars = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">in</span> charCount) &#123;<br>    <span class="hljs-keyword">if</span> (charCount[char] === maxCount) &#123;<br>      mostFrequentChars.<span class="hljs-title function_">push</span>(char);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> result = &#123;&#125;;<br>  <span class="hljs-comment">// 返回结果</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> mostFrequentChars) &#123;<br>    result[char] = maxCount;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br> <span class="hljs-comment">// 测试</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findMostFrequentCharacters</span>(<span class="hljs-string">&#x27;abcab&#x27;</span>)); <span class="hljs-comment">// 输出</span><br></code></pre></td></tr></table></figure><br>数组和链表的区别</p></blockquote><p>数组和链表是两种常见的数据结构，它们在存储和访问数据方面有一些区别：</p><ol><li><p>存储方式：数组是一种连续的内存结构，它将元素存储在相邻的内存位置上，而链表则是一种非连续的内存结构，它通过指针将元素存储在不同的内存位置上。</p></li><li><p>大小固定性：数组的大小是固定的，一旦创建，大小就不能改变。而链表的大小是可变的，可以根据需要动态添加或删除元素。</p></li><li><p>插入和删除操作：在数组中，插入和删除元素可能需要移动其他元素以保持连续性，这可能需要较长的时间。而在链表中，插入和删除元素只需要改变指针的指向，所以操作较为高效。</p></li><li><p>访问元素的效率：数组可以通过索引直接访问元素，所以访问元素的效率很高。而链表需要从头开始遍历链表才能找到目标元素，所以访问元素的效率较低。</p></li><li><p>内存占用：由于数组是连续的内存结构，所以它需要一块连续的内存空间来存储所有元素。而链表则可以使用分散的内存空间来存储元素，所以在存储大量元素时，链表可能占用的内存空间更少。</p></li></ol><p>综上所述，数组适合于需要快速访问元素的场景，而链表适合于需要频繁插入和删除元素的场景。</p><blockquote><p>用js实现flatten实现，将一个数组拍平，如 [1,’2’,[3,[4,5]]]转换为[1,’2’,3,4,5]</p></blockquote><p>以下是使用 JavaScript 实现数组拍平的代码：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = [];<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i])) &#123;<br>        <span class="hljs-title function_">helper</span>(arr[i]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        result.<span class="hljs-title function_">push</span>(arr[i]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">helper</span>(arr);<br>  <br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">// 输出 [1, &#x27;2&#x27;, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>以上代码使用递归的方式遍历数组，如果当前元素是数组，则递归调用 <code>helper</code> 函数拍平子数组；如果当前元素不是数组，则将其添加到结果数组中。最后返回结果数组。</p><blockquote><p>队列和栈的区别是什么？</p></blockquote><p>队列和栈是两种常见的数据结构，它们在元素的添加和删除操作上有所不同。</p><ol><li>队列（Queue）：</li></ol><ul><li>先进先出（FIFO）的原则，即最早添加的元素最先被删除。</li><li>元素从队尾添加，从队首删除。</li><li>类似于现实生活中排队的概念。</li><li>示例：打印队列、消息队列等。</li></ul><ol start="2"><li>栈（Stack）：</li></ol><ul><li>后进先出（LIFO）的原则，即最后添加的元素最先被删除。</li><li>元素从栈顶添加和删除。</li><li>类似于现实生活中堆叠的概念。</li><li>示例：函数调用栈、撤销操作、浏览器的历史记录等。</li></ul><p>总结：</p><ul><li>队列和栈都是用于存储和管理数据的数据结构，但它们的添加和删除操作顺序不同。</li><li>队列按照先进先出（FIFO）的原则进行操作，而栈按照后进先出（LIFO）的原则进行操作。</li><li>队列适用于需要按照顺序处理元素的场景，而栈适用于需要追踪最近操作或需要撤销操作的场景。</li></ul><hr><blockquote><p>给你一个整数数组nums，和一个整数k，请你返回其中出现频率前k高的元素，你可以按任意顺序返回答案</p></blockquote><p>以下是使用 JavaScript 实现给定一个整数数组 nums 和一个整数 k，返回其中出现频率前 k 高的元素的代码：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">nums, k</span>) &#123;<br>  <span class="hljs-comment">// 使用哈希表记录每个元素的出现频率</span><br>  <span class="hljs-keyword">const</span> frequencyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    frequencyMap.<span class="hljs-title function_">set</span>(num, (frequencyMap.<span class="hljs-title function_">get</span>(num) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 根据出现频率进行排序</span><br>  <span class="hljs-keyword">const</span> sortedNums = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(frequencyMap.<span class="hljs-title function_">keys</span>()).<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> frequencyMap.<span class="hljs-title function_">get</span>(b) - frequencyMap.<span class="hljs-title function_">get</span>(a));<br>  <br>  <span class="hljs-comment">// 返回前 k 个元素</span><br>  <span class="hljs-keyword">return</span> sortedNums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, k);<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> k = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">topKFrequent</span>(nums, k)); <span class="hljs-comment">// 输出 [1, 2]</span><br></code></pre></td></tr></table></figure><p>以上代码首先使用 Map 数据结构记录数组中每个元素的出现频率。然后，将所有不重复的元素按照出现频率进行排序，最后返回前 k 个元素。</p><blockquote><p>js实现实现一个大数计算的方法</p></blockquote><p>在JavaScript中，由于Number类型有限制，无法直接处理大数运算。但是可以使用字符串来模拟大数计算，通过手动实现相应的加减乘除运算。</p><p>以下是一个简单的示例，演示如何实现大数相加的方法：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addBigNumbers</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">let</span> i = num1.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> j = num2.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> digit1 = i &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">parseInt</span>(num1[i]) : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> digit2 = j &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">parseInt</span>(num2[j]) : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> sum = digit1 + digit2 + carry;<br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br>    result = (sum % <span class="hljs-number">10</span>) + result;<br>    i--;<br>    j--;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> num1 = <span class="hljs-string">&#x27;12345678901234567890&#x27;</span>;<br><span class="hljs-keyword">const</span> num2 = <span class="hljs-string">&#x27;98765432109876543210&#x27;</span>;<br><span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">addBigNumbers</span>(num1, num2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-comment">// 输出：111111111011111111100</span><br></code></pre></td></tr></table></figure><p>上述代码中，<code>addBigNumbers</code>函数接受两个大数字符串作为参数，并返回它们的相加结果。在函数中，我们使用了两个指针 <code>i</code> 和 <code>j</code> 分别从大数的末尾开始逐位相加，并使用 <code>carry</code> 变量来处理进位。最后，将每一位的结果拼接起来，得到最终的相加结果。</p><p>需要注意的是，上述代码只实现了大数相加的方法，其他的大数计算方法（如减法、乘法、除法）也可以类似地进行手动实现。</p><hr><blockquote><p>实现一个符合Promise A+规范的Promise库，只需实现then方法。</p></blockquote><p>下面是一个简单的符合Promise A+规范的Promise库的实现，仅包含<code>then</code>方法的实现：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Promise构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyPromise</span>(<span class="hljs-params">executor</span>) &#123;<br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>  self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span>; <span class="hljs-comment">// Promise的初始状态</span><br>  self.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Promise的结果值</span><br>  self.<span class="hljs-property">onResolvedCallbacks</span> = []; <span class="hljs-comment">// 存储所有成功回调的数组</span><br>  self.<span class="hljs-property">onRejectedCallbacks</span> = []; <span class="hljs-comment">// 存储所有失败回调的数组</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>; <span class="hljs-comment">// 修改Promise的状态为成功</span><br>      self.<span class="hljs-property">value</span> = value; <span class="hljs-comment">// 保存成功的结果值</span><br>      self.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>        <span class="hljs-title function_">callback</span>(value); <span class="hljs-comment">// 依次执行所有成功回调</span><br>      &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>; <span class="hljs-comment">// 修改Promise的状态为失败</span><br>      self.<span class="hljs-property">value</span> = reason; <span class="hljs-comment">// 保存失败的原因</span><br>      self.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>        <span class="hljs-title function_">callback</span>(reason); <span class="hljs-comment">// 依次执行所有失败回调</span><br>      &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">executor</span>(resolve, reject);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-title function_">reject</span>(e);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// then方法的实现</span><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">var</span> promise2;<br><br>  <span class="hljs-comment">// 处理参数默认值</span><br>  onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123; <span class="hljs-keyword">return</span> value; &#125;;<br>  onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123; <span class="hljs-keyword">throw</span> reason; &#125;;<br><br>  <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果Promise的状态已经是成功态，直接执行成功回调</span><br>    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onFulfilled</span>(self.<span class="hljs-property">value</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e);<br>        &#125;<br>      &#125;);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果Promise的状态已经是失败态，直接执行失败回调</span><br>    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">value</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e);<br>        &#125;<br>      &#125;);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果Promise的状态是等待态，将成功回调和失败回调存储起来，待状态改变时执行</span><br>    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>      self.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onFulfilled</span>(value);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;);<br>      &#125;);<br><br>      self.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onRejected</span>(reason);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解析Promise</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;循环引用&#x27;</span>));<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> called = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 避免多次调用</span><br><br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">var</span> then = x.<span class="hljs-property">then</span>;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        then.<span class="hljs-title function_">call</span>(x, <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) &#123;<br>          <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>          called = <span class="hljs-literal">true</span>;<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject);<br>        &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) &#123;<br>          <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>          called = <span class="hljs-literal">true</span>;<br>          <span class="hljs-title function_">reject</span>(r);<br>        &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是一个简单的符合Promise A+规范的Promise库的实现，其中包含了<code>MyPromise</code>构造函数和<code>then</code>方法的实现。需要注意的是，该实现仅是一个简单的示例，没有完整考虑所有边界情况和异步操作的处理。在实际应用中，还需要对Promise库进行更完善和严谨的实现。</p><hr><blockquote><p>js实现找出一个文本串中出现次数最多的文本段。如果出现概率一样多，取最长的文本；如果出现概率和长度一样，取得第一个文本。不考虑单个字母，以2位字符串作为最小的文本段单元。</p></blockquote><p>以下是一个实现找出一个文本串中出现次数最多的文本段的JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMostFrequentText</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-comment">// 将文本串拆分成2位字符串的数组</span><br>  <span class="hljs-keyword">const</span> segments = text.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/.&#123;2&#125;/g</span>);<br><br>  <span class="hljs-comment">// 统计每个文本段的出现次数</span><br>  <span class="hljs-keyword">const</span> countMap = &#123;&#125;;<br>  segments.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">segment</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (segment.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">if</span> (countMap[segment]) &#123;<br>        countMap[segment]++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        countMap[segment] = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-comment">// 找出出现次数最多的文本段</span><br>  <span class="hljs-keyword">let</span> maxCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> maxSegment = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> segment <span class="hljs-keyword">in</span> countMap) &#123;<br>    <span class="hljs-keyword">if</span> (countMap[segment] &gt; maxCount) &#123;<br>      maxCount = countMap[segment];<br>      maxSegment = segment;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (countMap[segment] === maxCount) &#123;<br>      <span class="hljs-comment">// 如果出现次数一样多，取最长的文本</span><br>      <span class="hljs-keyword">if</span> (segment.<span class="hljs-property">length</span> &gt; maxSegment.<span class="hljs-property">length</span>) &#123;<br>        maxSegment = segment;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (segment.<span class="hljs-property">length</span> === maxSegment.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-comment">// 如果出现次数和长度一样，取第一个文本</span><br>        <span class="hljs-keyword">if</span> (segments.<span class="hljs-title function_">indexOf</span>(segment) &lt; segments.<span class="hljs-title function_">indexOf</span>(maxSegment)) &#123;<br>          maxSegment = segment;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> maxSegment;<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;abcacacaab&#x27;</span>;<br><span class="hljs-keyword">const</span> mostFrequentText = <span class="hljs-title function_">findMostFrequentText</span>(text);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mostFrequentText); <span class="hljs-comment">// 输出&#x27;ca&#x27;</span><br></code></pre></td></tr></table></figure><p>上述代码中，<code>findMostFrequentText</code>函数接受一个文本串作为参数，并返回出现次数最多的文本段。首先，将文本串拆分成2位字符串的数组。然后，使用一个对象 <code>countMap</code> 统计每个文本段的出现次数。接着，遍历 <code>countMap</code> 对象，找出出现次数最多的文本段，并根据条件进行比较和更新。最后，返回出现次数最多的文本段。</p><p>需要注意的是，上述代码中使用了正则表达式 <code>/.&#123;2&#125;/g</code> 将文本串拆分成2位字符串的数组。如果需要将文本串拆分成其他长度的文本段，可以相应地修改正则表达式。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>URL解析，DNS，TCP（三次握手），HTTP请求响应过程，HTML、CSS、JS的加载顺序，DOM树、CSS树、渲染树，重绘和回流等。每个加载的流程都对应有性能优化的思路，如：DNS寻址原理和预解析；TCP连接有慢启动、拥塞控制所以要复用连接；HTTP2&#x2F;3优化请求效率；资源压缩、合并、减少请求等减少请求数据量；CDN、http缓存、前端缓存等；减少回流等渲染性能优化；worker、WebAssembly等脚本性能优化；服务端渲染、预加载、懒加载、骨架屏优化用户体验等等。</p></blockquote><p>URL解析：<br>URL解析是指将一个URL字符串解析成不同的组成部分，如协议、主机名、端口号、路径、查询参数等。以下是URL解析的步骤：</p><ol><li>使用正则表达式或URL解析库将URL字符串分解成不同的部分。</li><li>解析协议部分，确定使用的协议（如HTTP、HTTPS）。</li><li>解析主机名部分，确定要请求的服务器的主机名。</li><li>解析端口号部分，确定要请求的服务器的端口号。</li><li>解析路径部分，确定请求的资源在服务器上的路径。</li><li>解析查询参数部分，将查询参数解析成键值对的形式。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseUrl</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/^(https?):\/\/([^:/?]+)(?::(\d+))?(\/[^?]+)?(?:\?(.+))?$/</span>;<br>  <span class="hljs-keyword">const</span> matches = url.<span class="hljs-title function_">match</span>(regex);<br>  <span class="hljs-keyword">if</span> (matches) &#123;<br>    <span class="hljs-keyword">const</span> protocol = matches[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> host = matches[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">const</span> port = matches[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">const</span> path = matches[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">const</span> queryString = matches[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">const</span> queryParams = &#123;&#125;;<br>    <span class="hljs-keyword">if</span> (queryString) &#123;<br>      <span class="hljs-keyword">const</span> pairs = queryString.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> pairs) &#123;<br>        <span class="hljs-keyword">const</span> [key, value] = pair.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        queryParams[key] = value;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      protocol,<br>      host,<br>      port,<br>      path,<br>      queryParams<br>    &#125;;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;https://www.example.com:8080/path/to/resource?param1=value1&amp;param2=value2&#x27;</span>;<br><span class="hljs-keyword">const</span> parsedUrl = <span class="hljs-title function_">parseUrl</span>(url);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedUrl);<br></code></pre></td></tr></table></figure><p>DNS：<br>DNS（Domain Name System）是将域名转换为IP地址的系统。当用户在浏览器中输入一个域名时，浏览器需要通过DNS解析将域名转换为对应的IP地址，以便与服务器进行通信。以下是DNS解析的步骤：</p><ol><li>浏览器首先会检查本地缓存中是否有对应的域名解析结果，如果有则直接使用。</li><li>如果本地缓存中没有对应的解析结果，浏览器会向本地DNS服务器发送一个DNS解析请求。</li><li>本地DNS服务器会首先检查自己的缓存中是否有对应的解析结果，如果有则返回给浏览器。</li><li>如果本地DNS服务器的缓存中没有对应的解析结果，它会向根域名服务器发送一个请求，根域名服务器会返回负责该域名的顶级域名服务器的地址。</li><li>本地DNS服务器继续向顶级域名服务器发送请求，顶级域名服务器会返回负责该域名的权威域名服务器的地址。</li><li>本地DNS服务器继续向权威域名服务器发送请求，权威域名服务器会返回该域名对应的IP地址。</li><li>本地DNS服务器将解析结果返回给浏览器，并将结果缓存起来，以供下次使用。</li></ol><p>示例代码：<br>由于DNS解析是由浏览器自动完成的，无需编写代码进行DNS解析。</p><p>TCP（三次握手）：<br>TCP（Transmission Control Protocol）是一种可靠的传输协议，它使用三次握手来建立一个连接。以下是TCP三次握手的过程：</p><ol><li>客户端向服务器发送一个SYN（同步）报文，其中包含客户端的初始序列号。</li><li>服务器接收到SYN报文后，向客户端发送一个SYN-ACK（同步-确认）报文，其中包含服务器的初始序列号和确认号（客户端的初始序列号+1）。</li><li>客户端接收到SYN-ACK报文后，向服务器发送一个ACK（确认）报文，其中包含确认号（服务器的初始序列号+1）。</li><li>服务器接收到ACK报文后，连接建立成功。</li></ol><p>示例代码：<br>由于TCP连接的建立是由操作系统的网络协议栈完成的，无需编写代码进行TCP三次握手。</p><p>HTTP请求响应过程：<br>HTTP（Hypertext Transfer Protocol）是一种用于传输超文本的协议。以下是HTTP请求响应的过程：</p><ol><li>客户端向服务器发送一个HTTP请求，其中包含请求方法（如GET、POST）、URL、请求头和请求体（对于POST请求）等信息。</li><li>服务器接收到请求后，根据请求的URL和方法，处理请求并生成一个HTTP响应。</li><li>服务器将HTTP响应发送回客户端，其中包含响应状态码、响应头和响应体等信息。</li><li>客户端接收到响应后，根据响应的状态码和头部信息，对响应进行处理，如渲染页面或执行其他操作。</li></ol><p>示例代码：<br>由于HTTP请求和响应是由浏览器自动完成的，无需编写代码进行HTTP请求响应。</p><p>HTML、CSS、JS的加载顺序：<br>HTML、CSS和JS的加载顺序对于页面的渲染和交互行为有重要影响。一般情况下，浏览器会按照以下顺序加载HTML、CSS和JS：</p><ol><li>加载HTML：浏览器首先加载HTML文档，并构建DOM树。</li><li>加载CSS：浏览器在构建DOM树的过程中，遇到CSS链接标签（如<code>&lt;link&gt;</code>）或内联样式（如<code>&lt;style&gt;</code>），会开始加载CSS文件，并构建CSSOM树。</li><li>加载JS：浏览器在构建DOM树和CSSOM树的过程中，遇到JS脚本标签（如<code>&lt;script&gt;</code>），会开始加载JS文件，并执行其中的代码。</li></ol><p>示例代码：<br>HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>CSS（styles.css）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JS（script.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>DOM树、CSS树、渲染树：<br>DOM树（Document Object Model）是由HTML文档中的元素节点、文本节点和属性节点等组成的树状结构，表示了页面的结构和内容。<br>CSS树（CSS Object Model）是由CSS样式表中的规则和声明等组成的树状结构，表示了页面的样式规则。<br>渲染树（Render Tree）是由DOM树和CSS树合并而成的树状结构，表示了页面的渲染结果。</p><p>示例代码：<br>HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>CSS（styles.css）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染树：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Document<br><span class="hljs-bullet">  -</span> html<br><span class="hljs-bullet">    -</span> head<br><span class="hljs-bullet">      -</span> link<br><span class="hljs-bullet">    -</span> body<br><span class="hljs-bullet">      -</span> h1<br></code></pre></td></tr></table></figure><p>重绘和回流：<br>重绘（Repaint）是指当页面的样式发生改变，但布局不变时，浏览器会重新绘制页面的部分或全部内容。<br>回流（Reflow）是指当页面的布局发生改变，浏览器需要重新计算元素的位置和大小，然后重新绘制页面。</p><p>示例代码：<br>HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>CSS（styles.css）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重绘和回流的触发：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> h1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);<br>h1.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;blue&#x27;</span>; <span class="hljs-comment">// 触发重绘</span><br>h1.<span class="hljs-property">style</span>.<span class="hljs-property">marginLeft</span> = <span class="hljs-string">&#x27;200px&#x27;</span>; <span class="hljs-comment">// 触发回流和重绘</span><br></code></pre></td></tr></table></figure><p>性能优化的思路：</p><ol><li>DNS寻址原理和预解析：使用CDN将静态资源部署到离用户更近的地方，减少DNS解析的时间；在HTML中添加<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>标签，预解析域名，提前获取IP地址。</li><li>TCP连接复用：使用HTTP的持久连接，通过Connection头部字段设置keep-alive，使多个HTTP请求可以复用同一个TCP连接，减少TCP连接的建立和关闭的开销。</li><li>HTTP2&#x2F;3优化请求效率：使用HTTP2&#x2F;3协议，通过多路复用、头部压缩和服务器推送等技术，减少请求的延迟和数据量。</li><li>资源压缩、合并、减少请求：对CSS和JS进行压缩，将多个CSS和JS文件合并成一个文件，减少HTTP请求的数量和数据量。</li><li>CDN、HTTP缓存、前端缓存：使用CDN将静态资源缓存到离用户更近的地方，减少网络延迟；使用HTTP缓存和前端缓存，减少对服务器的请求。</li><li>减少回流等渲染性能优化：避免频繁修改样式，可以通过添加或删除CSS类名的方式来修改样式；使用transform和opacity等属性，避免触发回流。</li><li>Worker、WebAssembly等脚本性能优化：使用Web Worker将一些计算密集型的任务放到后台线程中执行，避免阻塞主线程；使用WebAssembly将性能敏感的代码编译为二进制格式，提高执行效率。</li><li>服务端渲染、预加载、懒加载、骨架屏优化用户体验：使用服务端渲染减少首屏加载时间；使用预加载和懒加载技术，提前加载或延迟加载资源；使用骨架屏展示页面的基本结构，提高用户感知的加载速度。</li></ol>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>讲一下http缓存的优先级？</p></blockquote><p>HTTP缓存的优先级由浏览器决定，通常按照以下顺序进行判断：</p><ol><li><p>强缓存（Expires和Cache-Control）：浏览器首先检查资源的<code>Expires</code>和<code>Cache-Control</code>头部字段。如果当前时间在<code>Expires</code>指定的过期时间之前，或者<code>Cache-Control</code>中指定了<code>max-age</code>并且没有过期，则直接使用缓存副本，不发送请求到服务器。</p></li><li><p>协商缓存（Last-Modified和ETag）：如果资源没有在强缓存中命中，浏览器会发送请求到服务器，服务器会检查资源的<code>Last-Modified</code>和<code>ETag</code>头部字段。如果<code>Last-Modified</code>指定的时间与浏览器上次请求时返回的时间相同，并且<code>ETag</code>也相同，则表示资源没有变化，服务器返回304 Not Modified状态码，浏览器继续使用缓存副本。</p></li><li><p>如果资源在协商缓存中也没有命中，则服务器返回200 OK状态码和新的资源内容，浏览器会更新缓存，并使用新的资源。</p></li></ol><p>需要注意的是，浏览器在判断缓存优先级时会根据配置和策略进行处理，不同浏览器可能会有一些差异。此外，开发者也可以通过设置响应头部字段来控制缓存行为，例如通过设置<code>Cache-Control</code>的<code>no-cache</code>或<code>no-store</code>来禁用缓存。</p><hr><blockquote><p>POST和GET的区别？</p></blockquote><p>POST和GET是HTTP协议中常用的两种请求方法，它们在以下几个方面有所区别：</p><ol><li><p>参数传递方式：GET请求通过URL参数传递数据，参数会附加在URL的末尾，以<code>?</code>分隔URL和参数，多个参数之间用<code>&amp;</code>连接。而POST请求的参数通常通过请求体传递，参数不会暴露在URL中。</p></li><li><p>请求长度限制：由于GET请求的参数暴露在URL中，URL的长度有限制，不同浏览器对URL长度的限制也不同，通常在2KB到8KB之间。而POST请求没有URL长度限制，可以传递大量数据。</p></li><li><p>安全性：GET请求的参数暴露在URL中，可能会被浏览器缓存、服务器日志等记录，不适合传递敏感信息。而POST请求的参数在请求体中，相对安全一些。</p></li><li><p>幂等性：GET请求是幂等的，即多次重复请求不会产生副作用，不会对资源产生影响。而POST请求通常用于提交数据、修改资源状态等，不是幂等的，多次请求可能会产生不同的结果。</p></li><li><p>缓存处理：GET请求默认可以被缓存，浏览器可以根据URL缓存响应结果。而POST请求默认不会被缓存，每次请求都会向服务器发送请求。</p></li></ol><p>需要根据具体的场景和需求选择使用GET或POST方法，GET适合请求数据，POST适合提交数据。</p><hr><blockquote><p>常见的http状态码？</p></blockquote><p>常见的HTTP状态码包括：</p><ol><li><p>1xx（信息性状态码）：表示请求已被接收，继续处理。</p></li><li><p>2xx（成功状态码）：表示请求已成功处理并返回响应。</p><ul><li>200 OK：请求成功，返回正常结果。</li><li>201 Created：请求成功，服务器创建了新资源。</li><li>204 No Content：请求成功，但响应中没有实体内容。</li></ul></li><li><p>3xx（重定向状态码）：表示需要进一步操作以完成请求。</p><ul><li>301 Moved Permanently：请求的资源已永久移动到新位置。</li><li>302 Found：请求的资源临时移动到新位置。</li><li>304 Not Modified：客户端使用缓存副本，资源未修改。</li></ul></li><li><p>4xx（客户端错误状态码）：表示请求包含语法错误或无法完成请求。</p><ul><li>400 Bad Request：请求无效，服务器无法理解。</li><li>401 Unauthorized：请求需要身份验证。</li><li>403 Forbidden：服务器理解请求，但拒绝执行。</li><li>404 Not Found：请求的资源不存在。</li></ul></li><li><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生错误。</p><ul><li>500 Internal Server Error：服务器遇到不可预知的错误。</li><li>503 Service Unavailable：服务器当前无法处理请求，通常是临时性的。</li></ul></li></ol><p>这只是一些常见的HTTP状态码，还有其他状态码可以根据需要使用。状态码可以帮助开发者和用户了解请求的处理情况，并根据不同的状态码进行相应的处理。</p><hr><blockquote><p>常用的跨域方案有哪些？</p></blockquote><p>常用的跨域解决方案包括：</p><ol><li><p>JSONP（JSON with Padding）：通过动态创建<code>&lt;script&gt;</code>标签来实现跨域请求，服务器返回的数据需要包裹在一个函数调用中，由客户端定义的回调函数来处理返回的数据。</p></li><li><p>CORS（Cross-Origin Resource Sharing）：在服务器端设置响应头部字段，允许指定的域名或所有域名访问资源。通过在服务器端设置<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>等头部字段来控制跨域访问的权限。</p></li><li><p>代理服务器：在同源策略限制下，通过在自己的服务器上建立代理，将跨域请求转发到目标服务器，再将结果返回给客户端。客户端与代理服务器之间不存在跨域问题。</p></li><li><p>WebSocket：WebSocket协议不受同源策略限制，可以与任意服务器建立双向通信。客户端与服务器之间通过WebSocket进行通信，可以实现跨域的数据交互。</p></li><li><p>postMessage：通过<code>window.postMessage</code>方法，可以在不同窗口或iframe之间进行跨域通信。可以通过消息事件监听来接收和处理跨域传递的数据。</p></li></ol><p>需要根据具体的场景和需求选择适合的跨域解决方案，确保安全性和可行性。</p><hr><blockquote><p>如何删除一个cookie？</p></blockquote><p>要删除一个cookie，可以通过设置cookie的过期时间为一个过去的时间来使其失效。以下是通过JavaScript来删除一个cookie的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteCookie</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = name + <span class="hljs-string">&quot;=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>deleteCookie</code>函数接受一个参数<code>name</code>，表示要删除的cookie的名称。通过将cookie的过期时间设置为过去的时间（比当前时间早），浏览器会将其视为已过期并删除该cookie。</p><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">deleteCookie</span>(<span class="hljs-string">&quot;myCookie&quot;</span>);<br></code></pre></td></tr></table></figure><p>这将删除名为”myCookie”的cookie。请注意，要成功删除一个cookie，需要确保在删除cookie时使用的路径和域与设置cookie时的路径和域相匹配。</p><hr><blockquote><p>讲下一个https协议建立连接的过程？</p></blockquote><p>HTTPS协议的建立连接过程如下：</p><ol><li><p>客户端发起请求：客户端向服务器发起HTTPS请求，连接的默认端口是443。</p></li><li><p>服务器证书：服务器将自己的证书发送给客户端。证书中包含了服务器的公钥和相关信息，证书通常由受信任的第三方机构（证书颁发机构，CA）签名，用于验证服务器的身份。</p></li><li><p>客户端验证证书：客户端收到服务器的证书后，会验证证书的有效性。这包括检查证书是否由受信任的机构签名（根证书是否存在于客户端的受信任根证书库中）、证书是否过期、域名是否与请求的域名匹配等。</p></li><li><p>客户端生成密钥：如果服务器的证书验证通过，客户端会生成一个随机的对称密钥，用于后续的加密通信。该对称密钥会使用服务器的公钥进行加密，以确保只有服务器能够解密。</p></li><li><p>密钥交换：客户端将加密后的对称密钥发送给服务器。</p></li><li><p>服务器解密密钥：服务器使用自己的私钥进行解密，获取客户端生成的对称密钥。</p></li><li><p>加密通信：客户端和服务器使用这个对称密钥进行加密和解密，保证后续的通信内容的机密性和完整性。</p></li></ol><p>通过以上步骤，客户端和服务器建立了安全的HTTPS连接，并可以进行加密通信。这样可以确保在传输过程中数据的保密性和完整性，防止被窃听和篡改。</p><hr><blockquote><p>跨域jsonp有什么限制</p></blockquote><p>JSONP（JSON with Padding）是一种跨域解决方案，但它也存在一些限制：</p><ol><li><p>只支持GET请求：JSONP是通过动态创建<code>&lt;script&gt;</code>标签来实现跨域请求的，因此只能使用GET方法发送请求，无法使用POST等其他方法。</p></li><li><p>只支持同步请求：由于JSONP是通过<code>&lt;script&gt;</code>标签加载远程脚本实现的，而脚本加载是同步的，因此无法实现异步请求。</p></li><li><p>安全性问题：JSONP的实现依赖于客户端对返回的数据进行处理，服务器返回的数据需要包裹在一个函数调用中。这就存在安全风险，如果服务器返回的数据被篡改或注入恶意代码，客户端可能会受到攻击。</p></li><li><p>只支持一次请求：JSONP只能发送一次请求，无法像AJAX那样进行多次请求和处理。</p></li><li><p>依赖服务器的支持：JSONP需要服务器端支持，服务器需要返回包裹在回调函数中的数据，而不是直接返回JSON格式的数据。</p></li></ol><p>需要注意的是，由于JSONP存在一些安全和功能限制，现在已经有更安全和灵活的跨域解决方案，如CORS（Cross-Origin Resource Sharing）。在使用JSONP时，应该注意安全性和数据可靠性，并根据具体需求和场景选择适合的跨域方案。</p><hr><blockquote><p>CORS简单请求和复杂请求的差别</p></blockquote><p>CORS（Cross-Origin Resource Sharing）是一种跨域解决方案，根据请求的复杂性，CORS可以分为简单请求和复杂请求，它们的主要差别在于浏览器对服务器端的请求预检（Preflight）和响应头部字段的要求。</p><p>简单请求（Simple Request）满足以下条件：</p><ol><li>请求方法为：GET、POST、HEAD。</li><li>请求头部字段只能为以下几种常见字段：Accept、Accept-Language、Content-Language、Content-Type（仅限于application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain）。</li></ol><p>对于简单请求，浏览器会直接发送请求，不会发送预检请求（OPTIONS请求），服务器端需要设置响应头部字段来允许跨域请求，主要包括：</p><ol><li><code>Access-Control-Allow-Origin</code>：指定允许访问的域名，可以是单个域名、多个域名或通配符*。</li><li><code>Access-Control-Allow-Credentials</code>：指定是否允许发送Cookie等凭证信息。</li><li><code>Access-Control-Allow-Methods</code>：指定允许的请求方法。</li><li><code>Access-Control-Allow-Headers</code>：指定允许的请求头部字段。</li></ol><p>复杂请求（Preflight Request）不满足简单请求的条件，主要包括：</p><ol><li>使用了非简单请求方法（如PUT、DELETE等）。</li><li>使用了自定义的请求头部字段。</li></ol><p>对于复杂请求，浏览器会先发送一个预检请求（OPTIONS请求），服务器需要响应预检请求并设置相应的响应头部字段，以告知浏览器是否允许实际请求。预检请求的响应头部字段与简单请求的响应头部字段类似，但需要多设置一个<code>Access-Control-Max-Age</code>字段，用于指定预检请求的有效期。</p><p>需要注意的是，对于复杂请求，浏览器在发送实际请求之前，会先发送预检请求，确保服务器允许跨域访问。服务器端需要正确处理预检请求并设置相应的响应头部字段，以确保跨域请求的顺利进行。</p><hr><blockquote><p>http状态码问完301和302的差别</p></blockquote><p>301和302是HTTP协议中的重定向状态码，用于指示客户端应该采取的下一步操作。它们的主要区别在于缓存策略和请求方法的保持。</p><ol><li><p>301 Moved Permanently（永久重定向）：表示请求的资源已永久移动到新的位置。客户端在接收到301响应后，应该更新其URL并将所有后续请求发送到新的URL。搜索引擎会将原始URL的搜索排名转移到新的URL上。此外，客户端在对301响应的资源进行缓存时，应该将新的URL视为有效的缓存标识符。</p></li><li><p>302 Found（临时重定向）：表示请求的资源临时移动到新的位置。客户端在接收到302响应后，应该继续使用原始URL进行后续请求。搜索引擎不会将原始URL的搜索排名转移到新的URL上。此外，客户端在对302响应的资源进行缓存时，应该将原始URL视为有效的缓存标识符。</p></li></ol><p>总结：</p><ul><li>301是永久重定向，客户端应该更新URL并将所有后续请求发送到新的URL，搜索引擎会更新搜索排名。</li><li>302是临时重定向，客户端应该继续使用原始URL进行后续请求，搜索引擎不会更新搜索排名。</li></ul><p>需要根据具体的需求和场景来选择合适的重定向状态码。</p><hr><blockquote><p>307是干嘛的</p></blockquote><p>307 Temporary Redirect（临时重定向）是HTTP协议中的一种重定向状态码。它与302 Found状态码的含义类似，都表示请求的资源临时移动到了新的位置。然而，307状态码在处理POST请求时与302有所不同。</p><p>307状态码要求客户端在接收到响应后继续保持请求方法不变，并将重定向请求发送到新的URL。这意味着对于原始的POST请求，客户端应该继续使用POST方法发送请求到新的URL上。这与302状态码不同，302状态码会导致客户端将POST请求转换为GET请求发送到新的URL上。</p><p>307状态码的主要目的是确保在重定向过程中保留原始请求的方法和消息主体，以便客户端能够按照预期进行正确的请求。这在某些情况下可能非常重要，例如在需要保持用户提交的表单数据时，使用307可以确保数据不会丢失。</p><p>需要注意的是，由于307状态码要求客户端保持请求方法不变，因此在某些旧版本的浏览器中可能会存在兼容性问题。在实际应用中，开发者需要根据具体需求和浏览器兼容性考虑来选择适合的重定向状态码。</p><hr><blockquote><p>webSocket、webRTC之类的原理</p></blockquote><p>WebSocket和WebRTC是两种不同的Web技术，它们分别用于实现实时通信和实时音视频通信。</p><ol><li>WebSocket原理：<br>WebSocket是一种基于TCP的全双工通信协议，它允许在客户端和服务器之间建立持久连接，以实现实时通信。WebSocket协议通过在标准的HTTP握手之后升级到WebSocket连接，使用特殊的帧格式进行数据传输。</li></ol><ul><li>客户端首先发送一个HTTP请求，包含特定的头部字段（如Upgrade和Connection），表明希望升级到WebSocket协议。</li><li>服务器收到请求后，可以选择接受或拒绝升级请求。如果接受，服务器会发送一个包含特定头部字段的HTTP响应，表明成功升级到WebSocket连接。</li><li>连接升级成功后，客户端和服务器之间可以通过WebSocket帧进行双向的实时通信。帧包括控制帧和数据帧，可以通过WebSocket API进行发送和接收。</li></ul><ol start="2"><li>WebRTC原理：<br>WebRTC（Web Real-Time Communication）是一种用于实时音视频通信的Web技术。它提供了一套API和协议，允许浏览器之间直接进行点对点的音视频传输，而无需通过中间服务器。</li></ol><ul><li>WebRTC使用ICE（Interactive Connectivity Establishment）协议来建立对等连接。ICE通过候选地址收集和网络遍历，找到可用的传输路径。</li><li>在对等连接建立之前，需要进行信令交换来协商连接参数和候选地址。信令可以使用各种协议，如WebSocket、HTTP、XMPP等。</li><li>一旦对等连接建立，WebRTC使用SRTP（Secure Real-Time Transport Protocol）进行音视频数据的传输。SRTP提供了加密和鉴别机制，确保数据的安全性和完整性。</li></ul><p>通过WebRTC，开发者可以在浏览器中实现实时音视频通信，如视频会议、实时游戏、远程教育等应用场景。</p><p>需要注意的是，WebSocket和WebRTC是两种不同的技术，用于不同的通信需求。WebSocket适用于一般的实时通信，而WebRTC专注于实时音视频通信。</p><hr><blockquote><p>WebSocket API有哪些</p></blockquote><p>WebSocket API是用于在Web浏览器中实现WebSocket协议的一组接口和方法。以下是一些常用的WebSocket API：</p><ol><li>WebSocket对象：表示WebSocket连接的实例。通过创建WebSocket对象来建立与服务器的连接。</li></ol><ul><li><p><code>new WebSocket(url[, protocols])</code>：创建一个新的WebSocket对象。<code>url</code>参数指定连接的URL，<code>protocols</code>参数是一个可选的字符串数组，指定了客户端支持的子协议。</p></li><li><p><code>WebSocket.readyState</code>：表示WebSocket连接的当前状态，包括CONNECTING、OPEN、CLOSING和CLOSED。</p></li><li><p><code>WebSocket.onopen</code>：当WebSocket连接成功打开时触发的事件处理程序。</p></li><li><p><code>WebSocket.onmessage</code>：当接收到服务器发送的消息时触发的事件处理程序。</p></li><li><p><code>WebSocket.send(data)</code>：将数据发送到服务器。</p></li><li><p><code>WebSocket.close([code[, reason]])</code>：关闭WebSocket连接。</p></li></ul><ol start="2"><li>事件处理程序：WebSocket对象支持一些事件处理程序，用于处理连接状态的变化和消息的接收。</li></ol><ul><li><p><code>onopen</code>：连接成功打开时触发的事件处理程序。</p></li><li><p><code>onmessage</code>：接收到消息时触发的事件处理程序。</p></li><li><p><code>onerror</code>：发生错误时触发的事件处理程序。</p></li><li><p><code>onclose</code>：连接关闭时触发的事件处理程序。</p></li></ul><p>以上是一些常用的WebSocket API，开发者可以利用这些API来创建WebSocket连接、发送和接收数据，并处理连接状态的变化。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React/Vue/小程序</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/22/React-Vue-%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/22/React-Vue-%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>常用Content-Type及应用？</p></blockquote><p>常用的Content-Type及其应用如下：</p><ol><li>text&#x2F;plain：纯文本格式，用于普通文本文件。</li><li>text&#x2F;html：HTML格式，用于网页文档。</li><li>text&#x2F;css：CSS格式，用于样式表文件。</li><li>text&#x2F;javascript：JavaScript格式，用于JavaScript代码文件。</li><li>application&#x2F;json：JSON格式，用于传输和存储结构化数据。</li><li>application&#x2F;xml：XML格式，用于传输和存储可扩展标记语言数据。</li><li>application&#x2F;pdf：PDF格式，用于传输和存储可打印文档。</li><li>image&#x2F;jpeg：JPEG格式，用于传输和存储图像。</li><li>image&#x2F;png：PNG格式，用于传输和存储图像。</li><li>audio&#x2F;mpeg：MPEG音频格式，用于传输和存储音频文件。</li><li>video&#x2F;mp4：MP4视频格式，用于传输和存储视频文件。</li></ol><p>这些Content-Type用于指示服务器和客户端如何处理传输的数据，确保数据能够正确解析和显示。</p><hr><blockquote><p>Vue&#x2F;React&#x2F;小程序有哪些生命周期？嵌套组件中，生命周期的触发顺序是怎样的？</p></blockquote><p>Vue、React和小程序的生命周期如下：</p><p>Vue的生命周期：</p><ol><li>beforeCreate：实例刚在内存中被创建出来，此时还没有初始化好data和methods属性。</li><li>created：实例已经在内存中创建完成，data和methods已经创建完成，此时还没有开始编译模板。</li><li>beforeMount：模板已经在内存中编译完成，但还没有挂载到页面中。</li><li>mounted：模板已经编译好，挂载到页面中显示，此时可以操作DOM了。</li><li>beforeUpdate：实例更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。</li><li>updated：虚拟DOM重新渲染和打补丁之后调用，组件更新完成。</li><li>beforeDestroy：实例销毁之前调用，此时实例仍然完全可用。</li><li>destroyed：实例销毁之后调用，此时组件已经被完全销毁，数据和方法都不可访问。</li></ol><p>React的生命周期：</p><ol><li>constructor：组件实例化时调用，用于初始化state和绑定方法。</li><li>static getDerivedStateFromProps：静态方法，用于根据props的变化来更新state。</li><li>render：渲染组件的内容。</li><li>componentDidMount：组件挂载完成后调用，此时可以操作DOM了。</li><li>shouldComponentUpdate：用于判断是否需要重新渲染组件，默认返回true。</li><li>getSnapshotBeforeUpdate：在更新之前获取DOM的快照，比如滚动位置。</li><li>componentDidUpdate：组件完成更新后调用，此时可以操作DOM了。</li><li>componentWillUnmount：组件即将销毁时调用，进行清理操作。</li></ol><p>小程序的生命周期：</p><ol><li>onLoad：页面加载时调用。</li><li>onShow：页面显示时调用，每次打开页面都会调用。</li><li>onReady：页面初次渲染完成时调用。</li><li>onHide：页面隐藏时调用。</li><li>onUnload：页面卸载时调用。</li><li>onPullDownRefresh：下拉刷新时调用。</li><li>onReachBottom：页面触底时调用。</li><li>onShareAppMessage：用户点击右上角分享时调用。</li></ol><p>在嵌套组件中，生命周期的触发顺序是父组件先于子组件，即父组件的生命周期会在子组件之前触发。具体的触发顺序会根据组件的实际情况而有所不同。</p><hr><blockquote><p>React hook是用来干嘛的？</p></blockquote><p>React Hook是React 16.8版本引入的一种新特性，用于在函数组件中使用状态和其他React特性。它的主要目的是让函数组件具备类组件的功能，使得开发更简洁、可维护性更高。</p><p>React Hook的主要作用如下：</p><ol><li><p>状态管理：使用useState Hook可以在函数组件中定义和使用状态，替代了类组件中的this.state和this.setState。可以通过useState在函数组件中保存和更新状态，使得状态管理更加直观和简单。</p></li><li><p>副作用处理：使用useEffect Hook可以在函数组件中处理副作用操作，替代了类组件中的生命周期方法。可以在useEffect中执行一些需要在组件渲染后或状态更新后执行的操作，如数据获取、订阅事件等。</p></li><li><p>上下文使用：使用useContext Hook可以在函数组件中使用上下文，替代了类组件中的static contextType和Context.Consumer。可以在函数组件中访问和更新上下文的值，实现跨组件的数据共享。</p></li><li><p>自定义Hook：通过自定义Hook可以将组件逻辑进行封装和复用，使得代码更加可读和可维护。自定义Hook是一个函数，可以在其中使用其他的React Hook，将一些逻辑进行封装，然后在多个组件中复用。</p></li></ol><p>React Hook的引入使得函数组件能够更好地处理状态和副作用，提升了开发效率和代码质量。它简化了组件的编写和维护，使得函数组件成为开发React应用的首选方式。</p><hr><blockquote><p>React Fiber 是什么？</p></blockquote><p>React Fiber是React 16版本引入的一种新的协调机制，用于实现React的更新和渲染。它是一种重新实现React核心算法的架构，旨在提升React在性能、并发和用户体验方面的表现。</p><p>传统的React渲染是基于递归的，即在进行组件更新时，React会遍历整个组件树，进行深度优先的递归操作。这种方式在大型应用中可能会导致长时间的渲染阻塞，影响用户体验。</p><p>React Fiber使用了一种新的协调机制，将渲染过程分成多个阶段，可以中断、恢复和优先处理不同优先级的任务。它采用了一种基于优先级的调度算法，可以根据任务的优先级动态地调整任务的执行顺序，使得高优先级的任务能够更快地得到处理，提升了应用的响应速度。</p><p>React Fiber的主要目标是实现以下几个方面的改进：</p><ol><li><p>增量渲染：将渲染过程分解成多个小任务，使得浏览器可以每帧执行一部分任务，提升应用的响应速度。</p></li><li><p>异步渲染：通过中断和恢复机制，可以在高优先级任务执行时中断低优先级任务的渲染过程，避免长时间的渲染阻塞。</p></li><li><p>优先级调度：根据任务的优先级动态地调整任务的执行顺序，使得高优先级的任务能够更快地得到处理，提升用户的交互体验。</p></li></ol><p>React Fiber的引入使得React能够更好地处理大型应用和复杂的UI交互，提升了React的性能和用户体验。同时，它也为React引入了更多的扩展和优化的可能性。</p><hr><blockquote><p>vue.nextTick是用来做什么的</p></blockquote><p>vue.nextTick是Vue.js中的一个方法，用于在下次DOM更新循环结束之后执行延迟回调。它主要用于获取更新后的DOM状态或操作DOM。</p><p>在Vue中，当数据发生变化时，Vue会异步执行DOM更新。这意味着在数据变化之后，直接访问DOM可能无法获取到最新的状态。为了解决这个问题，可以使用vue.nextTick方法。</p><p>vue.nextTick方法接受一个回调函数作为参数，该回调函数将在DOM更新循环结束之后执行。这样可以确保在回调函数中访问DOM时获取到最新的状态。</p><p>使用vue.nextTick的场景包括：</p><ol><li><p>在数据变化之后立即操作DOM：当需要在数据变化之后立即操作DOM时，可以将DOM操作代码放在vue.nextTick的回调函数中。</p></li><li><p>获取更新后的DOM状态：当需要获取更新后的DOM状态时，可以使用vue.nextTick来确保获取到最新的状态。</p></li><li><p>执行一些需要DOM更新完成后的操作：当需要执行一些需要在DOM更新完成后才能进行的操作时，可以使用vue.nextTick来确保操作的时机。</p></li></ol><p>总之，vue.nextTick方法可以在Vue的下次DOM更新循环结束后执行回调函数，用于操作更新后的DOM或获取最新的DOM状态。这样可以确保在正确的时机进行DOM操作，避免出现不一致或错误的操作。</p><hr><blockquote><p>vue.set是用来做什么的？为什么vue 3.0不需要了？</p></blockquote><p>vue.set是Vue.js 2.x版本中的一个方法，用于在响应式对象上添加响应式属性。它的作用是在Vue实例的数据对象中动态添加属性，并确保这个新添加的属性是响应式的。</p><p>在Vue 2.x中，当需要向响应式对象（如data中的对象）动态添加属性时，直接使用<code>obj.newProperty = value</code>的方式会导致新添加的属性不是响应式的，即对新属性的修改不会触发视图的更新。为了解决这个问题，可以使用vue.set方法。</p><p>vue.set方法接受三个参数：对象、属性名和属性值。它会在对象上添加一个新属性，并确保这个新属性是响应式的，即对新属性的修改能够触发视图的更新。</p><p>Vue 3.0中不再需要使用vue.set方法，原因如下：</p><ol><li><p>Vue 3.0使用了Proxy作为响应式系统的基础，而不再使用Object.defineProperty。Proxy可以监听对象的动态属性添加和删除，因此不再需要手动添加响应式属性。</p></li><li><p>在Vue 3.0中，直接使用<code>obj.newProperty = value</code>的方式添加属性，新属性会被自动设置为响应式的。</p></li><li><p>Vue 3.0引入了Composition API，提供了更灵活和强大的方式来处理组件的状态和逻辑，可以更方便地管理动态属性。</p></li></ol><p>综上所述，Vue 3.0不再需要使用vue.set方法来添加响应式属性，而是通过直接赋值的方式添加属性即可。这是因为Vue 3.0使用了Proxy作为响应式系统的基础，并且提供了更强大的Composition API来处理组件的状态和逻辑。</p><hr><blockquote><p>Vue的watch和computed有什么区别？分别应该在什么时候使用？</p></blockquote><p>Vue的watch和computed是用于监听数据变化的两种方式，它们有以下区别：</p><ol><li><p>功能：watch用于监听指定的数据变化并执行相应的回调函数，而computed用于计算衍生的数据属性。</p></li><li><p>依赖：watch可以监听任意数据的变化，包括响应式数据、非响应式数据和嵌套数据等。而computed只能依赖于已有的响应式数据，当依赖的数据发生变化时，computed会重新计算并返回新的值。</p></li><li><p>缓存：computed具有缓存机制，只有当依赖的数据发生变化时，computed才会重新计算。而watch不具有缓存机制，每当监听的数据发生变化时，都会执行相应的回调函数。</p></li><li><p>使用方式：watch需要在Vue实例的watch选项中定义监听的数据和回调函数。而computed需要在Vue实例的computed选项中定义计算属性的函数。</p></li></ol><p>适用场景：</p><ul><li><p>使用watch：当需要监听的数据变化时执行异步操作、复杂的逻辑处理、或需要深度监测对象或数组的变化时，可以使用watch。例如，监听用户输入的关键字变化并发送请求进行搜索。</p></li><li><p>使用computed：当需要根据已有的响应式数据计算衍生的数据属性时，可以使用computed。例如，根据商品的价格和数量计算总价。</p></li></ul><p>综上所述，watch适用于监听数据变化并执行相应的操作，而computed适用于计算衍生的数据属性。根据具体的需求和场景选择合适的方式来监听数据的变化。</p><hr><blockquote><p>服务端渲染有什么优势和劣势？</p></blockquote><p>服务端渲染（Server-Side Rendering，SSR）是指在服务器端将动态生成的HTML页面发送给浏览器进行渲染的一种技术。与传统的客户端渲染（Client-Side Rendering，CSR）相比，服务端渲染具有以下优势和劣势：</p><p>优势：</p><ol><li><p>更好的首屏加载性能：服务端渲染能够在服务器端生成完整的HTML页面，减少了客户端渲染时需要下载和执行JavaScript代码的时间，提升了首屏加载速度，改善了用户体验。</p></li><li><p>更好的SEO友好性：搜索引擎爬虫能够直接获取到完整的HTML页面内容，提高了页面被搜索引擎收录和排名的可能性。</p></li><li><p>更好的可访问性：服务端渲染可以保证页面内容在没有JavaScript支持或JavaScript出错的情况下仍然可以访问和使用，提升了网站的可访问性。</p></li></ol><p>劣势：</p><ol><li><p>服务器负载增加：服务端渲染需要在服务器端进行页面渲染，对服务器的负载有一定的影响，特别是在高并发情况下可能需要增加服务器的数量或性能。</p></li><li><p>开发复杂度增加：相对于客户端渲染，服务端渲染的开发复杂度较高，需要考虑服务器端和客户端的逻辑，并进行两者之间的数据同步和状态管理。</p></li><li><p>前后端分离困难：服务端渲染需要将前端代码和后端代码进行混合，不太适用于前后端分离的开发模式。</p></li></ol><p>综上所述，服务端渲染在首屏加载性能和SEO友好性方面具有优势，但在服务器负载和开发复杂度方面存在一定的劣势。选择是否使用服务端渲染需要根据具体项目需求和场景来进行权衡和选择。</p><hr><blockquote><p>虚拟Dom是什么？Vue&#x2F;React通过哪些方案来优化虚拟Dom更新真实dom的性能？</p></blockquote><p>虚拟DOM（Virtual DOM）是一种将真实DOM抽象为JavaScript对象的表示形式。它是对真实DOM的一种轻量级的内存对象模型，用于提高性能和渲染效率。</p><p>Vue和React都使用了虚拟DOM来进行组件的更新和渲染，以提高性能和优化DOM操作。</p><p>Vue和React通过以下方案来优化虚拟DOM更新真实DOM的性能：</p><ol><li><p>Diff算法：Diff算法用于比较新旧虚拟DOM树的差异，并只更新需要变化的部分。Vue使用的是双端比较的Diff算法，React使用的是Fiber架构中的增量更新算法。这些算法可以避免无谓的DOM操作，减少了更新的开销。</p></li><li><p>批量更新：Vue和React都提供了批量更新的机制，将多次状态变更合并为一次更新，减少了虚拟DOM的重建和真实DOM的操作次数，提高了性能。</p></li><li><p>异步更新：Vue和React都支持异步更新机制，将更新操作放入事件循环中，避免长时间的阻塞，提高了应用的响应速度。</p></li><li><p>虚拟DOM的复用：Vue和React会尽可能地复用虚拟DOM节点，减少创建和��毁节点的开销，提高了性能。</p></li><li><p>组件级别的更新：Vue和React将组件划分为更小的可独立更新的单元，只更新发生变化的组件，避免了全局更新的开销。</p></li><li><p>事件委托：Vue和React通过事件委托的方式，将事件监听器绑定在父元素上，避免了为每个子元素绑定事件监听器的开销。</p></li></ol><p>综上所述，Vue和React通过Diff算法、批量更新、异步更新、虚拟DOM的复用、组件级别的更新和事件委托等方式来优化虚拟DOM更新真实DOM的性能，提高了应用的性能和渲染效率。</p><hr><blockquote><p>Vue为什么 v-for 和 v-if 不建议⽤在⼀起？</p></blockquote><p>Vue中不建议同时在同一个元素上使用v-for和v-if的原因是，这样的组合在某些情况下可能会导致意外的结果和性能问题。</p><ol><li><p>渲染开销：当v-for和v-if一起使用时，v-for会在每次渲染循环时都执行v-if的条件判断，这会增加渲染的开销。如果列表中的每个项都需要经过v-if的条件判断，那么这个开销会随着列表的增加而增加。</p></li><li><p>逻辑混乱：v-for和v-if在同一个元素上使用时，会使模板的逻辑变得复杂和难以理解。因为v-for是在v-if之前运行的，所以在v-if的条件中使用v-for的项可能会导致逻辑混乱和难以预测的结果。</p></li></ol><p>为了避免这些问题，可以考虑使用computed属性或将v-if放在父元素上来处理筛选逻辑。这样可以更清晰地分离数据的筛选和渲染的逻辑，提高代码的可读性和维护性。</p><p>例如，可以使用computed属性来筛选数据，然后在模板中使用v-for渲染筛选后的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in filteredItems&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">items</span>: [</span><br><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Item 1&#x27;</span>, <span class="hljs-attr">visible</span>: <span class="hljs-literal">true</span> &#125;,</span><br><span class="language-javascript">        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Item 2&#x27;</span>, <span class="hljs-attr">visible</span>: <span class="hljs-literal">false</span> &#125;,</span><br><span class="language-javascript">        <span class="hljs-comment">// ...</span></span><br><span class="language-javascript">      ]</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">filteredItems</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">visible</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过这种方式，可以更清晰地将筛选逻辑和渲染逻辑分离，避免v-for和v-if同时使用时可能带来的问题。</p><hr><blockquote><p>vue-router hash 模式和 history 模式有什么区别？</p></blockquote><p>Vue Router提供了两种路由模式：hash模式和history模式。</p><ol><li><p>Hash模式：在hash模式下，URL中的路由路径会以<code>#</code>符号后面的部分表示，例如<code>http://example.com/#/home</code>。当URL中的hash值发生变化时，页面不会重新加载，而是触发Vue Router的路由切换。这种模式下，路由的变化不会影响到服务器端，因此可以在任何环境下运行，也不需要特殊的服务器配置。在旧版的浏览器中，hash模式也是唯一可行的路由模式。</p></li><li><p>History模式：在history模式下，URL中的路由路径不再有<code>#</code>符号，而是直接使用真实的URL路径，例如<code>http://example.com/home</code>。这种模式下，当URL发生变化时，会向服务器发送请求，因此需要服务器端的支持。为了避免在单页应用中出现404错误，需要在服务器端配置一个fallback页面，用于处理路由请求，确保在任何路径下都返回同一个HTML文件。</p></li></ol><p>区别：</p><ul><li>URL形式：hash模式的URL中包含<code>#</code>符号，而history模式的URL不包含<code>#</code>符号，更加直观和美观。</li><li>是否需要服务器支持：hash模式不需要服务器端的特殊配置，而history模式需要服务器端的支持，以确保在任何路径下都能够返回同一个HTML文件。</li><li>兼容性：hash模式兼容性更好，可以在任何环境下运行，而history模式在一些旧版浏览器中可能存在兼容性问题。</li></ul><p>在选择路由模式时，可以根据具体的需求和环境来决定。如果需要兼容性好且不需要服务器端支持，可以选择hash模式；如果需要更直观的URL形式和更好的用户体验，可以选择history模式，并进行服务器端的相应配置。</p><hr><blockquote><p>什么是高阶组件</p></blockquote><p>高阶组件（Higher-Order Component，HOC）是一种在React中用于复用组件逻辑的模式。它实际上是一个函数，接受一个组件作为参数，并返回一个新的组件。</p><p>高阶组件可以用来增强现有的组件，为它们添加额外的功能、修改现有的行为或封装一些共享的逻辑。它通过组件的组合和函数的复用，提供了一种灵活的方式来扩展和定制组件。</p><p>高阶组件的特点和用途包括：</p><ol><li><p>接受组件作为参数：高阶组件接受一个组件作为参数，并返回一个新的组件。</p></li><li><p>返回新的组件：高阶组件返回一个新的组件，这个新组件可以包装传入的组件，并对其进行一些增强或修改。</p></li><li><p>复用和共享逻辑：高阶组件可以封装一些通用的逻辑，使得多个组件可以共享这些逻辑，提高代码的复用性。</p></li><li><p>组件组合：多个高阶组件可以嵌套使用，形成组件的组合，实现更复杂的功能和逻辑。</p></li><li><p>功能增强和行为修改：高阶组件可以对传入的组件进行功能增强或行为修改，例如添加props、修改生命周期方法、封装数据请求等。</p></li></ol><p>使用高阶组件可以实现一些常见的功能，如：认证和授权、日志记录、错误处理、数据获取和处理、样式和主题等。它提供了一种灵活和可扩展的方式来组合和复用组件逻辑，使得代码更简洁、可维护性更高。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
      <category>Vue</category>
      
      <category>小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Vue</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复习笔记(一)</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h4><p>浏览器解析，查询缓存，dns查询，建立连接，服务器处理请求，服务器发送响应，客户端收到页面，解析html，构建渲染树，开始显示内容（白屏时间），首屏内容加载完成（首屏时间），用户可交互（DomContentLoaded），加载完成（load）</p><ul><li><p>浏览器进程：主进程，GPU进程，渲染进程，网络进程</p></li><li><p>渲染进程包括js引擎线程、事件触发线程、定时器触发线程、异步http请求线程、GUI渲染线程</p></li><li><p>js引擎线程主要负责解析js并运行代码，一直等待任务队列中的任务的到来，然后加以处理。当js引擎执行时，GUI渲染线程就会被挂起，GUI更新会被保存在一个队列中等到js引擎空闲时立即被执行</p></li><li><p>GUI渲染线程主要负责渲染浏览器界面，解析html、css构建DOM树和RenderObject树,布局，绘制。需要重绘或者由于某种操作引起回流时该线程就会执行。</p></li><li><p>GUI渲染线程和js引擎线程互斥,为了防止渲染结果的不可预期</p></li><li><p>事件触发线程：用来控制事件循环，当事件满足触发条件时，将事件放入到js引擎所在的执行队列中</p></li><li><p>定时器触发线程：setTimeout和setInterval所在的线程，定时任务并不是由js引擎计时的，是由定时触发线程计时的，计时完毕后通知事件触发线程</p></li><li><p>异步http请求线程：浏览器有一个单独的线程用于处理ajax请求，当请求完成，若有回调函数，通知事件触发线程。</p></li></ul><h4 id="为什么js是单线程的？"><a href="#为什么js是单线程的？" class="headerlink" title="为什么js是单线程的？"></a>为什么js是单线程的？</h4><ul><li>多线程的复杂性，多线程操作需要加锁，编码复杂性升高<br>如果同时操作dom，在多线程不加锁的情况下，最终会导致DOM渲染结果不可预期</li></ul><h4 id="为什么GUI渲染线程和js引擎线程互斥？"><a href="#为什么GUI渲染线程和js引擎线程互斥？" class="headerlink" title="为什么GUI渲染线程和js引擎线程互斥？"></a>为什么GUI渲染线程和js引擎线程互斥？</h4><ul><li><p>由于js是可以操作dom的，如果同时修改元素属性并同时渲染界面，那么渲染线程前后获得的元素就可能不一致。因此为了防止不可预期的结果，浏览器设定GUI渲染线程和js引擎线程为互斥关系</p></li><li><p>脚本加载：动态加载、异步加载</p></li></ul><h4 id="白屏时间、首屏时间、可交互时间计算问题"><a href="#白屏时间、首屏时间、可交互时间计算问题" class="headerlink" title="白屏时间、首屏时间、可交互时间计算问题"></a>白屏时间、首屏时间、可交互时间计算问题</h4><ul><li><p>白屏时间 &#x3D; 页面开始展示时间点 - 开始请求的时间点<br>开始请求的时间点，performance Timing.navigation Start</p></li><li><p>页面开始展示的时间点，开始解析body的时间点就是页面开始展示的时间，可以通过在head标签尾部插入script标签来统计时间节点，或者通过performance Timing.domLoading Start（直接忽略head解析时间）</p></li><li><p>首屏时间 &#x3D; 首屏内容渲染结束时间点 - 开始请求时间点</p></li><li><p>结束时间点可以通过以下几种方式获取</p></li><li><p>首屏模块的标签标记：在html文档中对应首屏内容的标签结束位置，使用内联的js代码记录当前的时间戳作为首屏内容渲染结束的时间点。</p></li><li><p>统计首屏内加载最慢的图片的时间：通常首屏内容加载最慢的就是图片资源，由于浏览器对每个页面的tcp连接数有限制，使得并不是所有的图片都能立刻开始下载和显示，因此在构建完成后会通过遍历首屏内的所有图片标签，并监听所有图片的onload事件，最终遍历图片标签的加载时间获取最大值，将这个最大值作为首屏时间</p></li><li><p>自定义首屏内容计算：统计首屏图片加载的时间比较复杂，所以忽略图片等资源的加载情况，只考虑页面主要dom，只考虑首屏的主要模块，而不是严格意义首屏线以上的所有内容</p></li><li><p>可交互时间 &#x3D; 用户可以正常进行交互的时间点 - 开始请求的时间点<br>performance Timing.domInactive,代表dom结构结束解析的时间点，即docuemnt.readyState变为inactive</p></li><li><p>性能检测工具</p><ul><li>chrome </li><li>performance</li><li>lighthouse</li></ul></li><li><p>火焰图：Main记录了渲染进程中主线程的执行记录</p><ul><li>Summary:各指标时间统计表</li><li>bottom-up:事件时长排序列表</li></ul></li><li><p>性能问题表现行为</p><ul><li><p>首屏白屏，打包文件过大，首屏加载时间过长，可能原因js阻塞页面渲染</p></li><li><p>交互卡顿，js执行时间过长，占用主线程，阻塞任务执行，不能在16.7ms内完成任务而掉帧</p><ul><li>相关知识点：</li></ul></li><li><p>webpack工作过程</p><ul><li><p>初始化，构建，生成</p></li><li><p>读取配置（webpack.config.js或者shell）参数创建一个编译器对象（compiler），初始化编译环境（注入内置插件、初始化ruleset集合、加载配置插件）,compiler执行run方法，找出entry中所有入口，调用compilation.addEntry将入口文件转换为dependence对象</p></li><li><p>编译模块：根据entry对应的dependence创建module对象，调用loader将模块转译为标准的js内容，调用js解释器将内容转换为AST对象，从中找出该模块依赖的模块，再递归本步骤直到左右入口依赖文件都经过了本步骤的处理，处理完成之后得到了每个模块被翻译后的内容以及他们之间的依赖关系图</p></li><li><p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入到输出列表，这是最后修改文件内容的机会。在确定好输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p></li></ul></li></ul></li></ul><h4 id="webpack工程化"><a href="#webpack工程化" class="headerlink" title="webpack工程化"></a>webpack工程化</h4><ul><li>babel编译+webpack打包<ul><li>webpack打包过程<ul><li>获取参数</li><li>初始化compiler（编译器）</li><li>根据entry中的配置找到入口文件</li><li>编译，调用所有配置loader对模块进行转化，递归，最终得到处理后的内容和    - 他们的依赖关系</li><li>根据入口和依赖关系组成一个个包含多个模块的chunck，再把chunck组装成一个bundle</li><li>根据配置确定输出路径和文件名，把内容写入文件</li></ul></li></ul></li><li>常用plugin有<ul><li>terser-webpack-plugin（压缩代码）</li><li>html-webpack-plugin(创建html文件到输出目录，将webpack打包后的chunk自动引入到这个html中)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlPlugin</span>(&#123;<br>  <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;index.html&#x27;</span>,<br>  <span class="hljs-attr">template</span>:<span class="hljs-string">&#x27;pages/index.html&#x27;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li>split-chunk-plugin：用来提取第三方库（react等）和公共代码（js、css），用于多页面应用程序，生成公共chunk，避免重复引用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">entry</span>:&#123;<br>    <span class="hljs-attr">vendor</span>: <span class="hljs-string">&#x27;./index.html&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title function_">commonChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>:[<span class="hljs-string">&#x27;vendor&#x27;</span>,<span class="hljs-string">&#x27;runtime&#x27;</span>],<br>      <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;[name].js&#x27;</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>常用loader：css-loader、style-loader</li></ul><h3 id="tree-shaking-是什么？有什么用？应用场景？有什么坑？怎么解决的？webpacke的tree-shaking和rollup的tree-shaking有何不同？"><a href="#tree-shaking-是什么？有什么用？应用场景？有什么坑？怎么解决的？webpacke的tree-shaking和rollup的tree-shaking有何不同？" class="headerlink" title="tree-shaking:是什么？有什么用？应用场景？有什么坑？怎么解决的？webpacke的tree-shaking和rollup的tree-shaking有何不同？"></a>tree-shaking:是什么？有什么用？应用场景？有什么坑？怎么解决的？webpacke的tree-shaking和rollup的tree-shaking有何不同？</h3><ul><li>通过静态分析之后，给没有被使用的代码打上标识，然后通过压缩工具删除</li><li>副作用：一个函数会或者可能会对函数外部产生影响的行为</li><li>esm&#x2F;import()</li><li>babel</li><li>压缩&#x2F;terser，unglyfy</li><li>公共包复用，split-chunk-plugin</li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>http https</li><li>http缓存</li><li>状态码</li><li>js异步</li><li>页面重绘重排</li><li>懒加载</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>less</p></li><li><p>变量和函数</p></li><li><p>嵌套和作用域</p></li><li><p>css隔离</p></li><li><p>运行时方案：BEM，命名规范， .block__element–modifier</p></li><li><p>编译时方案：</p><ul><li>属性选择器+唯一的ID属性，vue的scoped,vue-loader支持<br>css-modules,css-loader支持</li></ul></li><li><p>阶段划分</p><ul><li>webview容器初始化和主文档（html）下载</li><li>解析DOM和加载css</li><li>主js加载和执行，获取接口并执行剩下的js</li><li>渲染返回数据</li><li>优化点</li></ul></li><li><p>首屏优化</p><ul><li>native loading与h5骨架屏</li><li>串行接口请求移动到服务端处理</li><li>接口拆分，页面懒渲染，非实时更新数据缓存</li><li>数据请求优化</li><li>主接口预请求（prefetch）、请求失败重试</li><li>webpack打包体积优化方法</li><li>tree-shaking去除死代码</li></ul></li><li><p>代码分割：</p></li><li><p>入口配置(提取第三方库vendor)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">entry</span>:&#123;<br>    <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    <span class="hljs-attr">vendor</span>: [<span class="hljs-string">&#x27;react&#x27;</span>,<span class="hljs-string">&#x27;react-dom&#x27;</span>],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>optimization.splitChunks</p></li><li><p>默认值</p></li><li><p>新的chunk可以被共享，或者模块来自于node_modules</p></li><li><p>新的chunk体积大于20k</p></li><li><p>按需加载chunks时，并行请求的最大数量&lt;&#x3D;30</p></li><li><p>加载初始化页面时，并发请求最大数量&lt;&#x3D;30</p></li><li><p>当满足最后两个条件时，最好使用较大的chunks</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">splitChunks</span>:&#123;<br>    <span class="hljs-attr">chunks</span>:<span class="hljs-string">&#x27;async&#x27;</span>,<br>    <span class="hljs-attr">minSize</span>:<span class="hljs-number">3000</span>,<br>    <span class="hljs-attr">maxAsyncRequests</span>:<span class="hljs-number">5</span>,<br>    <span class="hljs-attr">maxInitialRequests</span>:<span class="hljs-number">3</span>,<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>按需加载和路由懒加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第三方库按需加载</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Button</span>,<span class="hljs-title class_">Select</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><br><span class="hljs-comment">// 路由的懒加载import()或者require.ensure()</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">detail</span> = (<span class="hljs-params"></span>)=&gt;<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/Detail&#x27;</span>);<br><span class="hljs-keyword">const</span> routes = [<br>    &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/comment&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([], <span class="hljs-title function_">r</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./Comment&#x27;</span>)), <span class="hljs-string">&#x27;comment&#x27;</span>)&#125;<br>];<br><br></code></pre></td></tr></table></figure></li><li><p>tree-shaking，用split-chunk-plugin（optimization的splitChunks）进行切割chunks，副作用和压缩工具terser协同处理死代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">- webpack之前版本<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UnglifyJsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;unglify-webpack-plugin&#x27;</span>);<br><span class="hljs-attr">plugins</span>:[<span class="hljs-keyword">new</span> <span class="hljs-title class_">UnglifyJsPlugin</span>()]<br><br> webpack4 配置<span class="hljs-attr">mode</span>:production<br></code></pre></td></tr></table></figure></li><li><p>渲染速度优化</p></li><li><p>逻辑代码优化</p></li><li><p>图片等静态资源优化</p></li><li><p>动画优化：对手机进行机型的等级划分为高端机、中端机和低端机，通过 window.navigation.user</p></li><li><p>交互优化</p></li><li><p>构建速度优化</p></li></ul><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ul><li>fiber:任务分割、异步执行，优先级</li><li>fiber架构的优点：随时暂停、恢复渲染、并发&#x2F;优先级渲染</li><li>fiber与调用栈的另一个区别是，栈帧在函数返回以后就销毁了，而fiber会在渲染结束以后继续存在，保存组件实例的信息（比如state）</li><li>为什么不使用generator来实现协作式调度？<ul><li>一方面，如果React全面使用generator，那么React内部的调度逻辑、用户编写的所有组件都是generator，这会给用户增加心智负担，并且大量使用generator会有不小的性能开销，过于依赖执行引擎的优化；</li><li>另一方面，Fiber架构能够更加灵活地让React从任意一个Fiber恢复执行（不只是从上次中断的地方恢复，而且能够从更早的Fiber恢复），而generator函数只能回到之前的yield状态，不能回到更早的执行状态。</li></ul></li></ul><h4 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h4><ul><li><p>react hooks如何理解它及实现原理？<br>类组件（难以实现拆分和复用）和函数组件（轻量、灵活和易于组织）<br>函数组件更加契合react的设计理念，UI&#x3D;F(data)<br>react hooks出现是为了帮助函数组件补全这些（相比于类组件）缺失的能力，改进react组件的开发模式</p></li><li><p>为什么useState要使用数组而不是对象</p><ul><li>es6解构赋值，</li><li>如果返回的是数组，那么使用者可以对元素命名，灵活方便，使用多次可以根据需要命名。可以降低使用的复杂度</li></ul></li></ul><h4 id="react-hooks解决了哪些问题"><a href="#react-hooks解决了哪些问题" class="headerlink" title="react hooks解决了哪些问题"></a>react hooks解决了哪些问题</h4><ul><li>组件之间复用状态逻辑</li><li>利于拆分逻辑，不必像类组件一样强制按照生命周期划分</li></ul><h4 id="react-hooks使用限制"><a href="#react-hooks使用限制" class="headerlink" title="react hooks使用限制"></a>react hooks使用限制</h4><ul><li>不要在循环、条件或者函数嵌套中调用hook</li><li>调用时按照顺序加入链表，如果在循环、条件和函数嵌套中调用很可能会导致取值错位执行错误的hooks</li><li>在react函数组件中调用hook</li></ul><h4 id="useEffect和useLayoutEffect区别"><a href="#useEffect和useLayoutEffect区别" class="headerlink" title="useEffect和useLayoutEffect区别"></a>useEffect和useLayoutEffect区别</h4><ul><li>同：处理副作用，底层调用同一个函数mountEffectImpl</li><li>异：useEffect在React渲染过程中是异步调用的，用于绝大多数场景,而useLayoutEffect在所有dom变更之后同步调用</li></ul><h4 id="react-hooks在平时开发的过程中需要注意的问题和原因"><a href="#react-hooks在平时开发的过程中需要注意的问题和原因" class="headerlink" title="react hooks在平时开发的过程中需要注意的问题和原因"></a>react hooks在平时开发的过程中需要注意的问题和原因</h4><ul><li><p>避免在循环、条件或嵌套函数中调用hook，必须在函数顶层使用hook</p><ul><li>因为react利用调用顺序来正确更新相应的状态，在这些情况下调用hook容易导致调用顺序不一致</li></ul></li><li><p>useState和push、pop、splice更改数组对象</p><ul><li><p>使用push直接更改数组无法获取到新值，在类组件中不会有问题</p></li><li><p>useState设置状态的时候只有第一次有效，后续更新需要通过useEffect</p></li></ul></li><li><p>useCallback</p></li><li><p>useContext</p></li></ul><h4 id="react-hooks和生命周期的关系"><a href="#react-hooks和生命周期的关系" class="headerlink" title="react hooks和生命周期的关系"></a>react hooks和生命周期的关系</h4><ul><li>constructor等同于useState</li><li>getDerivedStateFromProps等同于useState里的update函数</li><li>useEffect cleanup等同于componentwillunmount</li></ul><h4 id="虚拟dom（跨平台和渲染性能）"><a href="#虚拟dom（跨平台和渲染性能）" class="headerlink" title="虚拟dom（跨平台和渲染性能）"></a>虚拟dom（跨平台和渲染性能）</h4><ul><li><p>真实的dom的js对象抽象表示，配合不同的渲染工具使跨平台渲染成为可能。通过事物处理机制可以将多次DOM修改的结果一次性更新到页面上，减少页面的渲染次数，提高渲染性能。</p></li><li><p>每次数据发生变化时，虚拟dom都会缓存一份，变化之时，现在的虚拟dom都会与缓存的虚拟dom进行对比，在vue或react封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p></li><li><p>现代前端框架的一个基本要求就是无需手动操作dom，手动操作dom无法保证程序性能，多人开发可能出现性能较低的代码，另一方面省略手动dom操作可以大大提高开发效率</p></li><li><p>虚拟dom可以保证性能下限，在不进行手动优化的情况下，提供过得去的性能。</p></li></ul><p>真实dom：html字符串+重建所有dom<br>虚拟dom：生成vnode+diff+必要的dom更新</p><p>虚拟dom另一个好处就是跨平台</p><h4 id="react-diff算法原理"><a href="#react-diff算法原理" class="headerlink" title="react diff算法原理"></a>react diff算法原理</h4><ul><li><p>通过对比两颗虚拟dom树的变更差异，将更新的补丁作用于真实dom，以最小代价完成视图更新</p></li><li><p>diff算法的三个策略，分别基于树，组件、节点<br>  shouldComponentUpdate</p></li><li><p>树同层级比较，忽略节点跨层级操作，提升对比效率</p></li><li><p>组件对比，类型不同，不对比直接重渲染，同类型组件可以通过shouldComponentUpdate、PureComponent、React.memo()来判断是否需要diff</p></li><li><p>组件中同层级元素列表对比，插入、移动和删除操作，稳定、可预测并且唯一的key可以提高节点复用</p></li></ul><h4 id="react-key的作用？为什么要加上key？主要解决什么问题？"><a href="#react-key的作用？为什么要加上key？主要解决什么问题？" class="headerlink" title="react key的作用？为什么要加上key？主要解决什么问题？"></a>react key的作用？为什么要加上key？主要解决什么问题？</h4><ul><li><p>react key可以通过key来标识元素是新创建的还是移动的，提高节点复用，从而减少不必要的diff和重渲染</p></li><li><p>react key主要用于追踪列表中的哪些元素被修改、被添加或被删除的辅助标识。</p></li></ul><h3 id="tcp和udp最大区别"><a href="#tcp和udp最大区别" class="headerlink" title="tcp和udp最大区别"></a>tcp和udp最大区别</h3><h4 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h4><ul><li>http特性<br>可扩展协议、无状态有会话、基于tcp&#x2F;tls连接，http依赖于面向连接的tcp进行消息传递</li></ul><h4 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h4><ul><li>副作用和幂等：对服务器资源做修改即副作用，幂等即发送m和n次请求（两者不相同且都大于1），服务器上资源的状态一致。get是无副作用、幂等的，post主要是有副作用、不幂等的</li><li>技术上区分<ul><li>get请求能缓存，post请求不能</li><li>get请求没有post请求那么安全，因为请求都在url中，且会被浏览器保存历史记录，post请求放在请求体中更安全</li><li>url有长度限制，会干预get请求，浏览器决定</li><li>get请求只能进行url编码，只能接收ascii字符。而post没有限制，支持更多的编码类型，而且不对数据类型做限制</li><li>get请求会把请求报文一次性发出去，而post会分为两个tcp数据包，首先发送header部分，如果服务器响应100（continue），然后发送body部分</li></ul></li></ul><h4 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h4><p>1XX: 信息状态码，服务器收到请求，需要请求者继续执行操作<br>2XX: 成功状态码，操作被成功接收并处理<br>3XX: 重定向状态码，需要进一步操作以完成请求</p><p>301: 永久重定向<br>302: 临时重定向<br>304: 未修改（协商缓存）<br>4XX: 客户端错误状态码，<br>400: 客户端请求语法错误<br>401: 发送的请求需要有通过http认证的认证信息<br>403: 请求资源的访问被服务器拒绝<br>404: 服务器上没有找到请求的资源<br>5XX: 服务器错误状态码,<br>500: 服务器内部错误<br>501: 服务器不支持当前请求所需要的某个功能<br>502: 无效网关<br>503: 服务器暂时处于超负载或正在停机维护，无法处理请求<br>504: 网关超时</p><h4 id="http-头部"><a href="#http-头部" class="headerlink" title="http 头部"></a>http 头部</h4><p>request headers、response headers</p><h4 id="http1-0、http1-1、http2、http3区别"><a href="#http1-0、http1-1、http2、http3区别" class="headerlink" title="http1.0、http1.1、http2、http3区别"></a>http1.0、http1.1、http2、http3区别</h4><ul><li>http1.0:<ul><li>引入http头概念</li><li>content-type，具备了传输除纯文本HTML文件以外其他类型文档的能力</li><li>每个tcp连接只能发送一个请求，发送数据完毕，连接就关闭，tcp建立成本很高。</li><li>短连接，每一个http请求都由它自己独立的连接完成，意味着发起的每一个- http请求之前都会有一次tcp握手</li></ul></li><li>http1.1:<ul><li>连接可以复用，长连接，默认开启connection:key-alive。在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。</li><li>增加管道：允许在第一个应答被完全发送完成之前就发送第二个请求，降低通信延迟。复用同一个tcp连接期间，即便是通过管道同时发送了多个请求，服务端也是按照请求的顺序依次给出响应的。客户端在未收到之前所发出所有请求的响应之前，将会阻塞后面的请求（排队等待），即“队头阻塞”。</li><li>支持响应分块，分块编码传输，即Transfer-Encoding:chunked Content-length声明本次响应的数据长度。使用Content-length字段的前提是服务器发送响应之前必须知道响应数据的长度。</li><li>引入额外的缓存控制机制，在Http1.0中主要使用header里的If-Modified-Since,Expires来作为缓存的判断标准，Http1.1则引入更多的缓存判断的标准，Entity tag,If-None-Match,Cache-Control等</li></ul></li><li>http2.0<ul><li>二进制协议</li><li>多路复用，允许同时通过单一的HTTP2连接发起多重的请求-响应消息</li><li>采用二进制格式传输取代http1的文本格式，单个连接上可以并行交错的请求和响应，之间互不干扰。</li><li>解决队头阻塞问题，二进制分帧层，交错发送，重新组装</li><li>压缩headers</li><li>服务端推送</li></ul></li></ul><h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><ul><li>对称加密</li><li>非对称加密</li><li>公钥加密数据，私钥解密数据，私钥掌握在颁发公钥的一方</li></ul><h5 id="https中间人攻击发生在哪个阶段？"><a href="#https中间人攻击发生在哪个阶段？" class="headerlink" title="https中间人攻击发生在哪个阶段？"></a>https中间人攻击发生在哪个阶段？</h5><ul><li><p>tls握手过程</p></li><li><p>客户端发起一个http请求，告诉服务器自己支持哪些hash算法</p></li><li><p>服务端把自己的信息以数字证书的形式返回给客户端，证书中包含公钥和密钥，私钥由服务器持有</p></li><li><p>客户端收到服务器的响应之后会先验证证书的合法性（证书中包含的地址和正在访问的地址是否一致，证书是否过期），验证通过后客户端就会生成一个密钥，并且用公钥加密，让服务端用私钥解密，解密后就用这个密钥进行数据传输</p></li><li><p>服务端收到加密过的随机数并使用私钥解密获得R3,这时候两端都拥有了3个随机数，可以通过这3个随机值按照之前约定的加密方式生成密钥。接下来的通信就可以通过该密钥来加密解密</p></li></ul><h5 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h5><h6 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h6><ul><li><p>Cache-Control和Expires</p></li><li><p>Expires的值和头里面的Date属性的值来判断缓存是否还有效。Expires是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，无需再次请求。Expires的一个缺点是返回的到期时间是服务器的时间，是一个绝对的时间，如果客户端时间和服务器时间不一致，就会存在误差</p></li><li><p>Cache-Control指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发送请求到服务器取数据，其设置的是一个相对时间。</p></li><li><p>Cache-Control:max-age&#x3D;31536000表示距离发起请求31536000s内都可以命中缓存</p></li><li><p>Cache-Control:no-store表示没有缓存</p></li><li><p>Cache-Control:no-cache表示有缓存但要重新验证</p></li><li><p>Cache-control:private表示私有缓存，专用于某单个用户的，中间人（中间代理、cdn等缓存）不能缓存此响应</p></li><li><p>Cache-control:public表示公有缓存，中间人可以缓存响应</p></li></ul><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><ul><li><p>If-Modifed-Since、Last-Modified</p></li><li><p>Last-Modified表示本地文件最后修改日期，浏览器会在request header加上If-Modifed-Since(上次Last-Modified的值),询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，但是如果在本地打开缓存文件，就会造成Last-Modifed被修改，所以在HTP&#x2F;1.1出现了ETag</p></li><li><p>If-none-match、ETags<br>资源的变化都会导致ETag变化，和最后修改时间没有关系，Etag可以保证这个资源的唯一性，If-None-match的header会将上次返回的Etag发送给服务器，询问该资源的etag是否有更新，有变动就会发送新的资源回来。</p></li><li><p>If-none-match、ETags的优先级高于If-Modified-Since 、Last-Modified</p></li></ul><p>cookie<br>跨域</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 多叉树遍历</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">layerSum</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">children</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> root.<span class="hljs-property">children</span>) &#123;<br>      sum += <span class="hljs-title function_">traverse</span>(item) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">traverse</span>(root) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> res = <span class="hljs-title function_">layerSum</span>(&#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;] &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> &#125;] &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">7</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">8</span> &#125;] &#125;<br>  ]<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><br></code></pre></td></tr></table></figure><h3 id="虚拟dom转真实dom"><a href="#虚拟dom转真实dom" class="headerlink" title="虚拟dom转真实dom"></a>虚拟dom转真实dom</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 虚拟dom转真实dom</span><br><span class="hljs-keyword">const</span> vnode = &#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;DIV&#x27;</span>,<br>  <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;app&#x27;</span> &#125;,<br>  <span class="hljs-attr">children</span>: [&#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;SPAN&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-attr">children</span>: [] &#125;]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;SPAN&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123; <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-attr">children</span>: [] &#125;,<br>      &#123; <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-attr">children</span>: [] &#125;<br>    ]<br>  &#125;<br>  ]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vnode</span>) &#123;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setAttr</span> = (<span class="hljs-params">node, attrs</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!attrs) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">const</span> kv = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(attrs);<br>    <span class="hljs-keyword">if</span> (kv.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> kv) &#123;<br>        node.<span class="hljs-title function_">setAttribute</span>([item[<span class="hljs-number">0</span>]], item[<span class="hljs-number">1</span>]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>);<br>  <span class="hljs-title function_">setAttr</span>(root, vnode.<span class="hljs-property">attrs</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">root, node</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(node.<span class="hljs-property">children</span>[i].<span class="hljs-property">tag</span>);<br>      <span class="hljs-title function_">setAttr</span>(element, node.<span class="hljs-property">children</span>[i].<span class="hljs-property">attrs</span>);<br>      root.<span class="hljs-title function_">appendChild</span>(element);<br>      <span class="hljs-title function_">buildTree</span>(root.<span class="hljs-property">children</span>[i], node.<span class="hljs-property">children</span>[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">buildTree</span>(root, vnode);<br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-title function_">render</span>(vnode)<br></code></pre></td></tr></table></figure><h4 id="实现new"><a href="#实现new" class="headerlink" title="实现new"></a>实现new</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个空对象</span><br><span class="hljs-comment"> * this指向</span><br><span class="hljs-comment"> * 原型链完整</span><br><span class="hljs-comment"> * 返回</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">fn,...args</span>)&#123;<br>  <span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj.<span class="hljs-property">__proto__</span>;<br>  <span class="hljs-keyword">const</span> ret = fn.<span class="hljs-title function_">apply</span>(obj,args)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret===<span class="hljs-string">&#x27;object&#x27;</span>?<span class="hljs-attr">ret</span>:obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现compose"><a href="#实现compose" class="headerlink" title="实现compose"></a>实现compose</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = (<span class="hljs-params">arr</span>)=&gt;&#123;<br>  <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>===<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,curr</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>)=&gt;</span><span class="hljs-title function_">pre</span>(<span class="hljs-title function_">curr</span>(args))<br>  &#125;)<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现防抖和节流"><a href="#实现防抖和节流" class="headerlink" title="实现防抖和节流"></a>实现防抖和节流</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//防抖</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">fn</span>)=&gt;&#123;<br>  <span class="hljs-keyword">const</span> timer= <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">if</span>(timer!==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>),<span class="hljs-number">300</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 节流</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span>=(<span class="hljs-params">fn</span>)=&gt;&#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">if</span>(timer===<span class="hljs-literal">null</span>)&#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer=<span class="hljs-literal">null</span>;<br>      &#125;,<span class="hljs-number">300</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现promise-finally方法"><a href="#实现promise-finally方法" class="headerlink" title="实现promise.finally方法"></a>实现promise.finally方法</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不管成功或者失败都调用</span><br><span class="hljs-comment"> * finally不接收参数，但需要链式传递</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>data),<br>    <span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">fn</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">throw</span> err)<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现promise-all方法"><a href="#实现promise-all方法" class="headerlink" title="实现promise.all方法"></a>实现promise.all方法</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 记录resolve次数</span><br><span class="hljs-comment"> * 返回结果存入顺序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_all</span> = (<span class="hljs-params">pList</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> ans = [];<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    pList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        ans[i] = res;<br>        count++;<br>        <span class="hljs-keyword">if</span> (count === pList.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(ans);<br>      &#125;).<span class="hljs-title function_">catch</span>(reject)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现promise-race方法"><a href="#实现promise-race方法" class="headerlink" title="实现promise.race方法"></a>实现promise.race方法</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">_race</span> = (<span class="hljs-params">pList</span>)=&gt;&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    pList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span>=&gt;</span>&#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(fn).<span class="hljs-title function_">then</span>(resolve,reject);<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现promise-allSettled方法"><a href="#实现promise-allSettled方法" class="headerlink" title="实现promise.allSettled方法"></a>实现promise.allSettled方法</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">_allSettled</span> = (<span class="hljs-params">pList</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> ans = [];<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">valid</span> = (<span class="hljs-params">callback, i, result</span>) =&gt; &#123;<br>    count++;<br>    ans[i] = result;<br>    <span class="hljs-keyword">if</span> (count === pList.<span class="hljs-property">length</span>) <span class="hljs-title function_">callback</span>(ans);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    pList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-title function_">valid</span>(resolve, i, res))<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">valid</span>(reject, i, err));<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="请求-promise-并发"><a href="#请求-promise-并发" class="headerlink" title="请求(promise)并发"></a>请求(promise)并发</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">scheduledPromise</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">maxLimit, pList, callback</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> ret = [];<br>  <span class="hljs-keyword">const</span> runPool = [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> pList) &#123;<br>    <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(item));<br>    ret.<span class="hljs-title function_">push</span>(p);<br><br>    <span class="hljs-keyword">if</span> (pList.<span class="hljs-property">length</span> &gt; maxLimit) &#123;<br>      <span class="hljs-keyword">const</span> e = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> runPool.<span class="hljs-title function_">splice</span>(runPool.<span class="hljs-title function_">indexOf</span>(e), <span class="hljs-number">1</span>));<br>      runPool.<span class="hljs-title function_">push</span>(e);<br>      <span class="hljs-keyword">if</span> (runPool.<span class="hljs-property">length</span> &gt;= maxLimit) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(runPool);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(ret);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="请求-promise-重试"><a href="#请求-promise-重试" class="headerlink" title="请求(promise)重试"></a>请求(promise)重试</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">promiseRetry</span> = (<span class="hljs-params">fetchData,times</span>)=&gt;&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fetchData</span>())<br>      .<span class="hljs-title function_">then</span>(resolve).<span class="hljs-title function_">catch</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        --times==<span class="hljs-number">0</span> ? <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;重试次数达到上限&#x27;</span>) : <span class="hljs-title function_">run</span>();<br>      &#125;)<br>    &#125;<br>    <span class="hljs-title function_">run</span>();<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="请求-promise-超时"><a href="#请求-promise-超时" class="headerlink" title="请求(promise)超时"></a>请求(promise)超时</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">promiseTimeout</span> = (<span class="hljs-params">fetchData, time</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> timeout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;超时了&#x27;</span>), time));<br>  <span class="hljs-keyword">const</span> pList = [timeout, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fetchData</span>())];<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(pList);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数组扁平化</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * flatter([1, 2, [1, [2, 3, [4, 5, [6]]]]]);</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">flatter</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!arr.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? [...pre, ...<span class="hljs-title function_">flatter</span>(cur)] : [...pre, cur];<br>  &#125;, []);<br>&#125;<br><br><br><span class="hljs-comment">// 迭代方式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">flatter2</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!arr.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>    arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="深拷贝，忽略function、循环引用、undefined等"><a href="#深拷贝，忽略function、循环引用、undefined等" class="headerlink" title="深拷贝，忽略function、循环引用、undefined等"></a>深拷贝，忽略function、循环引用、undefined等</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">deepClone</span> = (<span class="hljs-params">obj</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;<br>  <span class="hljs-keyword">const</span> ans = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item !== <span class="hljs-string">&#x27;object&#x27;</span> || item === <span class="hljs-literal">null</span>) &#123;<br>      ans[item] = obj[item];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ans[item] = <span class="hljs-title function_">deepClone</span>(obj[item]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: &#123; <span class="hljs-attr">d</span>: <span class="hljs-number">1</span> &#125; &#125; &#125; &#125;<br><span class="hljs-keyword">const</span> deepObj = <span class="hljs-title function_">deepClone</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj === deepObj, deepObj)<br></code></pre></td></tr></table></figure><h3 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>)&#123;<br>   b = <span class="hljs-number">20</span>;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <br>&#125;)();<br></code></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>; i++)&#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>   &#125;, <span class="hljs-number">1000</span>,i)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>异步</li><li>promise</li><li>promise 链是分阶段构造的，因此在处理异步函数时必须注意对错误函数的处理</li><li>Promise then 第二个参数和catch的区别是什么?</li><li>模拟实现finally <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-keyword">let</span> P = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">value</span>  =&gt;</span> P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> value),<br>    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="async-await：特性、串行并行、错误处理"><a href="#async-await：特性、串行并行、错误处理" class="headerlink" title="async-await：特性、串行并行、错误处理"></a>async-await：特性、串行并行、错误处理</h3><ul><li><p>async 函数</p></li><li><p>async函数返回一个promise，如果返回值不是promise，则会用promise包装一下返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125; <br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)&#125;<br></code></pre></td></tr></table></figure></li><li><p>await表达式会暂停整个async函数的执行进程并让出其控制权，只有当异步返回成功或者失败才会恢复，如果在forEach里则不会被阻塞</p></li><li><p>await关键字只有在async函数中有效，在async主体外使用会抛语法错误</p></li><li><p>async函数体等价于由多个或0个await表达式分割开的，第一行代码到第一个await是同步执行的，不含await的async函数会同步执行，函数体内只要有await就会异步执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">await</span> <span class="hljs-number">1</span>&#125; <br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-literal">undefined</span>)&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;1&quot;</span>), <span class="hljs-number">1000</span>));<br>  <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;2&quot;</span>), <span class="hljs-number">500</span>));<br>  <span class="hljs-keyword">const</span> results = [<span class="hljs-keyword">await</span> p1, <span class="hljs-keyword">await</span> p2]; <span class="hljs-comment">// 不推荐使用这种方式，请使用 Promise.all 或者 Promise.allSettled</span><br>&#125;<br><span class="hljs-title function_">foo</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123; &#125;); <span class="hljs-comment">// 捕捉所有的错误...</span><br><br><span class="hljs-comment">// </span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params">msg</span>) =&gt; <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg))<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 串行</span><br>  <span class="hljs-comment">// await next(1)</span><br>  <span class="hljs-comment">// await next(2)</span><br>  <span class="hljs-comment">// 并行</span><br>  <span class="hljs-keyword">const</span> a = <span class="hljs-title function_">next</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> b = <span class="hljs-title function_">next</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">await</span> a;<br>  <span class="hljs-keyword">await</span> b;<br>&#125;<br><br><br><span class="hljs-comment">// async 重写promise链</span><br><span class="hljs-comment">// 前</span><br><span class="hljs-comment">// async function getData(url) &#123;</span><br><span class="hljs-comment">//   return fetchData(url)</span><br><span class="hljs-comment">//     .catch((e) =&gt; fallback(e))</span><br><span class="hljs-comment">//     .then((v) =&gt; handleData(v))</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 后</span><br><span class="hljs-comment">// async function getData(url) &#123;</span><br><span class="hljs-comment">//   let v;</span><br><span class="hljs-comment">//   try &#123;</span><br><span class="hljs-comment">//     v = await fetchData(url);</span><br><span class="hljs-comment">//   &#125; catch (e) &#123;</span><br><span class="hljs-comment">//     v = fallback(e)</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//   return handleData(v);</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="输出代码顺序"><a href="#输出代码顺序" class="headerlink" title="输出代码顺序"></a>输出代码顺序</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);  <br><br><span class="hljs-title function_">async1</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="setTimeout和setInterval"><a href="#setTimeout和setInterval" class="headerlink" title="setTimeout和setInterval"></a>setTimeout和setInterval</h3><ul><li>为什么要用 settimeout 模拟实现 setinterval？setinterval 的缺陷是什么？<br>每个setTimeout产生的任务会直接push到任务队列中，而setInterval每次把任务push到任务队列前，都要进行以下判断，看上次的任务是否还在队列中，如果有则不添加，没有则添加。</li></ul><hr><p>用户时长统计上报<br>何时开始：document监听事件DOMContentLoaded,window监听事件load（兜底）<br>何时结束：页面销毁<br>如何防作弊<br>怎么判断是否空闲：window监听，toustart和scroll事件<br>如何解决上报出错问题<br>白名单和黑名单<br>与宿主页面的隔离</p><h3 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h3><ul><li>虚拟滚动列表：滚动锚定、计算顶部偏移量</li><li>核心原理：<ul><li>监听滚动，在合适的时机在上方或者下方增加偏移量，</li><li>不可见区域用空的div把高度撑起来</li><li>把容器内的撑开，形成滚动条，滚动条的偏移scrollTop</li></ul></li><li>原理：核心就是通过监听滚动来判断当前dom距离顶部的位置，计算可视区域第一条item距离顶部的高度 scrollTop<br>适用<br>1.每一项都等高</li><li>ahooks：useInfiniteScroll、useVirtualList</li><li>useVirtualList存在问题：<ul><li>闪烁</li><li>抖动</li><li>拖动滚动条时自动无限加载</li><li>回调函数</li><li>无法覆盖复杂情况（不定高的瀑布流）</li></ul></li></ul><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><ul><li>BFC</li><li>flex</li><li>flex:1<ul><li>flex: 0 1 auto;<ul><li>flex-grow: 空间剩余时放大比例，0代表空间剩余，项目不放大</li><li>flex-shrink: 空间不足时缩小比例，1代表空间不足，项目将缩小</li><li>flex-basis: 分配多余空间之前，项目占据的主轴空间，设置宽度值跟着宽度走，没有设置宽度（auto）则按实际宽度走。</li></ul></li></ul></li></ul><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ul><li><p>响应式原理</p></li><li><p>渲染机制</p></li><li><p>computed原理</p></li><li><p>手写classnames</p></li></ul><h4 id="vue指令系统"><a href="#vue指令系统" class="headerlink" title="vue指令系统"></a>vue指令系统</h4><ul><li><p>v-if原理,v-if和v-show区别</p></li><li><p>v-for作用域、v-for遍历对象、v-if和v-for同时存在、v-for和key、- v-for原理</p></li><li><p>v-on和v-bind</p></li><li><p>双向绑定及v-model原理</p></li><li><p>生命周期及其作用域和执行上下文（this）问题</p></li><li><p>生命周期钩子可以用箭头函数吗？</p></li><li><p>watch原理</p></li><li><p>组件通信：props+$emit、provide+inject</p></li><li><p>组件插槽：固定名，动态名、数据传递</p></li><li><p>模版解析</p></li><li><p>组件注册</p></li><li><p>异步组件：defineAsyncComponent</p></li><li><p>props传递、单向数据流</p></li><li><p>组合式函数（composition api）原理</p></li><li><p>组合式函数与Mixin、无渲染组件、react hooks对比</p></li><li><p>自定义指令和插件</p></li><li><p>vue构建部署、安全、性能、稳定性等问题</p></li><li><p>vue 虚拟dom diff：静态提升、更新标记</p></li><li><p>this.$attrs</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>复习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue知识一</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/20/Vue%E7%9F%A5%E8%AF%86%E4%B8%80/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/20/Vue%E7%9F%A5%E8%AF%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="因为vue的响应式系统是通过属性访问进行追踪的"><a href="#因为vue的响应式系统是通过属性访问进行追踪的" class="headerlink" title="因为vue的响应式系统是通过属性访问进行追踪的"></a>因为vue的响应式系统是通过属性访问进行追踪的</h3><ul><li>这也是为什么 ref包裹一个像string number和boolean这样的原始类型时，要用.value</li><li>reactive 不能直接将其属性赋值或解构至本地变量，或是将该属性传入一个函数时，会失去响应式   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><br><span class="hljs-comment">// n 是一个局部变量，和 state.count 失去响应性连接</span><br><span class="hljs-keyword">let</span> n = state.<span class="hljs-property">count</span><br><span class="hljs-comment">// 不会影响 state</span><br>n++<br><br><span class="hljs-comment">// count 也和 state.count 失去了响应性连接</span><br><span class="hljs-keyword">let</span> &#123; count &#125; = state<br><span class="hljs-comment">// 不会影响 state</span><br>count++<br><br><span class="hljs-comment">// 参数 count 同样和 state.count 失去了响应性连接</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callSomeFunction</span>(<span class="hljs-params">count</span>) &#123;<br>  <span class="hljs-comment">// 不会影响 state</span><br>  count++<br>&#125;<br><span class="hljs-title function_">callSomeFunction</span>(state.<span class="hljs-property">count</span>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React事件</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/19/React%E4%BA%8B%E4%BB%B6/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/19/React%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<ul><li>React 靠的是Hook调用的顺序 <ul><li>只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。</li></ul></li><li>自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/19/Git/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/19/Git/</url>
    
    <content type="html"><![CDATA[<ul><li>git config –list看看当前的配置<ul><li>git config –global user.name name  估计你需要配置你的名字</li><li>git config –global user.email email address 希望别人看到你的commit可以联系到你</li></ul></li><li>git clone master地址<ul><li>git config –global http.sslVerify “false” 拉不下来就执行这个 主要</li><li>git config –global –unset https.proxy 拉不下来就执行这个</li></ul></li><li>git init 如果还没有Git仓库</li><li>git remote add name git-repo-url 如果你想关联远程仓库</li><li>git remote add   another-name   another-git-repo-url 如果你想关联多个远程仓库</li><li>git remote -v  忘了关联了哪些仓库或者地址</li><li>git clone git-repo-url 如果远程有仓库，你需要clone到本地</li><li>git remote   set-url   origin    your-git-url 如果你想把别人仓库的地址改为自己的</li><li>git status 查文件状态 红色的代表是没有追踪到</li><li>git add . 手动添加进去 没有追踪到的直接手动添加上去 当前目录下的所有更改</li><li>git remote add origin “远程场库地址”</li><li>git checkout -b “自己的分支名”<ul><li>git stash 默认有标识</li><li>git stash save messageName  标记存储 方便后期查看</li><li>git stash push 将文件给push到一个临时空间中</li><li>git stash list 查看修改缓存对列</li><li>git stash apply messageName 取出指定index的储藏的修改到工作区中</li><li>git stash pop 将文件从临时空间pop下来，可取出最近一次储藏的修改到工作区中，并同时将该储藏从储藏记录列表中删除</li></ul></li><li>git checkout  file-name 恢复暂存区文件到工作区<ul><li>git branch 查看本地分支</li><li>git branch -a 查看本地仓库和本地远程场库（远程场库的本地镜像）的所有分支</li></ul></li><li>git commit -m “ 提交信息” 双引号 单引号会有fail  </li><li>执行完commit之后，会在仓库中生成一个版本号(hash值)，标志这次提交。之后任何时候，都可以借助这个hash值回退到这次提交。<ul><li>commit 提交代码</li><li>切换分支master</li><li>master同步远程代码并合并</li><li>切换自己的分支，rebase本地master分支，可推你的远程分支，可推可不推</li><li>切回本地master分支，merge本地自己分支</li><li>git push 推到远程分支master</li></ul></li><li>git reset –hard <hash code>   回退到任意版本<ul><li>git reset –hard 回到未修改的状态，清空暂存区和工作区相当于 git reset git checkout<ul><li>git reset 暂存区的修改恢复到工作区</li><li>git reset –hard HEAD^想回退到上一个版本，有没有简便方法?</li></ul></li><li>git reset –soft   与git reset等价，回到已修改状态，修改的内容仍然在工作区中</li></ul></li><li>git pull -u origin master  第一次需要关联上 保证自己的分支上要与远程master同步   即最新的代码 在进行下一步  <ul><li>git push 之后在推送就不用指明</li></ul></li><li>git log 查看历史版本</li><li>先运行，运行有时会不成功,是因为要解决冲突，按着打印台报错信息去找哪个文件哪个地方出现冲突，直接取看保留哪个地方，直到能正常运行</li><li>拉下来运行成功之后  再commit 一波  </li><li>git push origin “自己的分支名”</li><li>在coding上创建合并请求 并通知管理提个pr</li><li>合并请求时要进行判断那些是留下的 把不要的直接删了</li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/19/React/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/19/React/</url>
    
    <content type="html"><![CDATA[<blockquote><p>React是一个网页UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</p></blockquote><blockquote><p>它的核心设计思路有三点，分别是声明式、组件化与通用性。声明式的优势在于直观与组合。</p></blockquote><blockquote><p>组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合。</p></blockquote><blockquote><p>通用性在于一次学习，随处编写。比如React Native, React360 等，这里主要靠虚拟DOM来保证实现。</p></blockquote><blockquote><p>这使得React的适用范围变得足够广，无论是Web、Native、 VR,甚至Shell应用都可以进行开发。这也是React的优势。</p></blockquote><blockquote><p>但作为一个视图层的框架，React 的劣势也十分明显。它并没有提供完整的一揽子解决方案，在开发大型前端应用时，需要向社区寻找并整合解决方案。虽然一定程度上促进了社区的繁荣，但也为开发者在技术选型和学习适用上造成了一定的成本。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/xuxiaodi666/my-blog.git/2023/08/19/hello-world/"/>
    <url>/xuxiaodi666/my-blog.git/2023/08/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
